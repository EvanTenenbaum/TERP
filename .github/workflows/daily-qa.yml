name: Nightly Mega QA Pipeline

on:
  schedule:
    # Run every day at 2:00 AM UTC (more time for full suite)
    - cron: '0 2 * * *'
  
  workflow_dispatch:
    inputs:
      skip_slack:
        description: 'Skip Slack notification'
        type: boolean
        default: false
      force_run:
        description: 'Force run even if no changes'
        type: boolean
        default: false
      quick_mode:
        description: 'Run in quick mode (fewer tests)'
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  NODE_VERSION: '20'

jobs:
  run-e2e-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: terp_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps chromium

      - name: Wait for MySQL
        run: |
          until mysqladmin ping -h 127.0.0.1 -P 3306 --silent; do
            echo "Waiting for MySQL..."
            sleep 2
          done

      - name: Setup test database (schema only, no mock data)
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
        run: |
          pnpm db:push
          # Skip seeding - tests should work with empty database or use existing production data

      - name: Build application
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
        run: pnpm build

      - name: Start application server
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
          NODE_ENV: test
          PORT: 5173
          JWT_SECRET: test-secret-for-ci-only-32chars!!
        run: |
          pnpm start &
          sleep 10
          curl --retry 10 --retry-delay 2 --retry-connrefused http://localhost:5173/health || true

      - name: Run Mega QA Suite
        id: mega_qa
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
          CI: true
          MEGA_QA_MODE: ${{ inputs.quick_mode && 'quick' || 'ci' }}
        run: |
          # Run full Mega QA (E2E + property tests + contracts)
          if [ "${{ inputs.quick_mode }}" = "true" ]; then
            pnpm mega:qa:quick || true
          else
            pnpm mega:qa:ci || true
          fi
          echo "tests_completed=true" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Process Results & Stage Bugs
        id: qa_pipeline
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          # Stage bugs for approval (don't auto-add to roadmap)
          pnpm tsx scripts/qa/stage-pending-bugs.ts || true
          
          # Send interactive Slack report
          pnpm tsx scripts/qa/send-interactive-report.ts || true
          
          # Check if new bugs were found
          if [ -f qa-results/pending-bugs.json ]; then
            NEW_BUGS=$(jq '.bugs | length' qa-results/pending-bugs.json)
            echo "new_bugs=$NEW_BUGS" >> $GITHUB_OUTPUT
          else
            echo "new_bugs=0" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mega-qa-results-${{ github.run_id }}
          path: |
            qa-results/
            playwright-report/
            test-results/
          retention-days: 30

      - name: Commit pending bugs (staged, not roadmap)
        if: steps.qa_pipeline.outputs.new_bugs != '0'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Only commit the pending bugs file (roadmap updated via Slack approval)
          if [ -f qa-results/pending-bugs.json ]; then
            git add qa-results/pending-bugs.json
            git add qa-results/mega-qa/
            git commit -m "chore(qa): stage ${{ steps.qa_pipeline.outputs.new_bugs }} bugs for approval [skip ci]" || true
            git push || true
          fi

      - name: Create summary issue
        if: steps.qa_pipeline.outputs.new_bugs != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('qa-results/latest-report.json', 'utf-8'));
            
            const newBugs = report.newBugs || [];
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            
            let body = `## ðŸ¤– Automated QA Report - ${new Date().toLocaleDateString()}\n\n`;
            body += `**Test Results:** ${report.passed}/${report.totalTests} passed\n`;
            body += `**New Bugs Found:** ${newBugs.length}\n\n`;
            
            if (newBugs.length > 0) {
              body += `### New Bugs Added to Roadmap\n\n`;
              for (const bugId of newBugs) {
                body += `- [ ] \`${bugId}\`\n`;
              }
              body += `\n`;
            }
            
            body += `### Details\n\n`;
            body += `- Duration: ${Math.round(report.duration / 60000)}m\n`;
            body += `- Failed: ${report.failed}\n`;
            body += `- Skipped: ${report.skipped}\n`;
            body += `- Flaky: ${report.flaky}\n\n`;
            
            body += `[View Full Report](${runUrl})\n\n`;
            body += `---\n*This issue was automatically created by the Daily QA Pipeline.*`;
            
            // Check for existing open QA issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'automated-qa',
              state: 'open'
            });
            
            if (issues.data.length > 0) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: body
              });
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ðŸ¤– QA Report: ${newBugs.length} new bugs found`,
                labels: ['automated-qa', 'bug'],
                body: body
              });
            }

      - name: Send Slack notification (manual trigger)
        if: github.event_name == 'workflow_dispatch' && !inputs.skip_slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -f qa-results/latest-report.json ]; then
            echo "Slack notification already sent by qa-pipeline.ts"
          fi
