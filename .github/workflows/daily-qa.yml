name: Daily QA Pipeline

on:
  schedule:
    # Run every day at 6:00 AM UTC
    - cron: '0 6 * * *'
  
  workflow_dispatch:
    inputs:
      skip_slack:
        description: 'Skip Slack notification'
        type: boolean
        default: false
      force_run:
        description: 'Force run even if no changes'
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  NODE_VERSION: '20'

jobs:
  run-e2e-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: terp_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps chromium

      - name: Wait for MySQL
        run: |
          until mysqladmin ping -h 127.0.0.1 -P 3306 --silent; do
            echo "Waiting for MySQL..."
            sleep 2
          done

      - name: Setup test database
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
        run: |
          pnpm db:push
          pnpm seed:light

      - name: Build application
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
        run: pnpm build

      - name: Start application server
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
          NODE_ENV: test
          PORT: 5173
          JWT_SECRET: test-secret-for-ci-only-32chars!!
        run: |
          pnpm start &
          sleep 10
          curl --retry 10 --retry-delay 2 --retry-connrefused http://localhost:5173/health || true

      - name: Run E2E tests
        id: e2e_tests
        env:
          DATABASE_URL: mysql://root:testpassword@127.0.0.1:3306/terp_test
          CI: true
        run: |
          # Playwright config already has JSON reporter configured to output test-results.json
          pnpm exec playwright test || true
          echo "tests_completed=true" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Run QA Pipeline
        id: qa_pipeline
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          pnpm tsx scripts/qa/index.ts test-results.json || true
          
          # Check if new bugs were found
          if [ -f qa-results/latest-report.json ]; then
            NEW_BUGS=$(jq '.newBugs | length' qa-results/latest-report.json)
            echo "new_bugs=$NEW_BUGS" >> $GITHUB_OUTPUT
          else
            echo "new_bugs=0" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qa-results-${{ github.run_id }}
          path: |
            test-results.json
            qa-results/
            playwright-report/
          retention-days: 30

      - name: Commit roadmap updates
        if: steps.qa_pipeline.outputs.new_bugs != '0'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are changes to commit
          if git diff --quiet docs/roadmaps/MASTER_ROADMAP.md qa-results/ docs/prompts/; then
            echo "No changes to commit"
          else
            git add docs/roadmaps/MASTER_ROADMAP.md
            git add qa-results/
            git add docs/prompts/
            git commit -m "chore(qa): add ${{ steps.qa_pipeline.outputs.new_bugs }} new bugs from automated QA [skip ci]"
            git push
          fi

      - name: Create summary issue
        if: steps.qa_pipeline.outputs.new_bugs != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('qa-results/latest-report.json', 'utf-8'));
            
            const newBugs = report.newBugs || [];
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            
            let body = `## ðŸ¤– Automated QA Report - ${new Date().toLocaleDateString()}\n\n`;
            body += `**Test Results:** ${report.passed}/${report.totalTests} passed\n`;
            body += `**New Bugs Found:** ${newBugs.length}\n\n`;
            
            if (newBugs.length > 0) {
              body += `### New Bugs Added to Roadmap\n\n`;
              for (const bugId of newBugs) {
                body += `- [ ] \`${bugId}\`\n`;
              }
              body += `\n`;
            }
            
            body += `### Details\n\n`;
            body += `- Duration: ${Math.round(report.duration / 60000)}m\n`;
            body += `- Failed: ${report.failed}\n`;
            body += `- Skipped: ${report.skipped}\n`;
            body += `- Flaky: ${report.flaky}\n\n`;
            
            body += `[View Full Report](${runUrl})\n\n`;
            body += `---\n*This issue was automatically created by the Daily QA Pipeline.*`;
            
            // Check for existing open QA issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'automated-qa',
              state: 'open'
            });
            
            if (issues.data.length > 0) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: body
              });
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ðŸ¤– QA Report: ${newBugs.length} new bugs found`,
                labels: ['automated-qa', 'bug'],
                body: body
              });
            }

      - name: Send Slack notification (manual trigger)
        if: github.event_name == 'workflow_dispatch' && !inputs.skip_slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -f qa-results/latest-report.json ]; then
            echo "Slack notification already sent by qa-pipeline.ts"
          fi
