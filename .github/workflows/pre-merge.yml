name: Pre-Merge Quality Gate

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  quality-gate:
    runs-on: ubuntu-latest
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for git diff to compare with main

      - name: Extract Task ID
        id: extract_task
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          if [[ $BRANCH_NAME =~ ^claude/([A-Z]+-([0-9]+|[0-9]{8}-[0-9]{3}))-[0-9]{8}- ]]; then
            echo "task_id=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
          else
            echo "task_id=" >> $GITHUB_OUTPUT
          fi

      # =================================================================
      # SECURITY PATTERN ENFORCEMENT (Only checks CHANGED files)
      # =================================================================
      - name: Get Changed Files
        id: changed_files
        run: |
          # Get list of changed .ts/.tsx files in this PR
          CHANGED=$(git diff --name-only origin/main...HEAD -- '*.ts' '*.tsx' 2>/dev/null || true)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check for Forbidden Security Patterns
        id: security_check
        run: |
          VIOLATIONS=""
          CHANGED_FILES="${{ steps.changed_files.outputs.files }}"

          # Skip if no TypeScript files changed
          if [ -z "$CHANGED_FILES" ]; then
            echo "has_violations=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Pattern 1: Fallback user ID (BUG-PATTERN: POST-002)
          # Matches: ctx.user?.id || 1, ctx.user.id || 1, ctx.user?.id ?? 1, etc.
          FALLBACK_MATCHES=""
          for file in $CHANGED_FILES; do
            if [ -f "$file" ]; then
              MATCH=$(grep -n -E "ctx\.user\??\.(id|userId)\s*(\|\||\?\?)\s*[0-9]" "$file" 2>/dev/null || true)
              if [ -n "$MATCH" ]; then
                FALLBACK_MATCHES="${FALLBACK_MATCHES}${file}:${MATCH}\n"
              fi
            fi
          done
          if [ -n "$FALLBACK_MATCHES" ]; then
            VIOLATIONS="${VIOLATIONS}### ❌ Fallback User ID Pattern\n\nFound forbidden pattern \`ctx.user?.id || 1\`. Use \`getAuthenticatedUserId(ctx)\` instead.\n\n\`\`\`\n${FALLBACK_MATCHES}\`\`\`\n\n"
          fi

          # Pattern 2: Actor from input (BUG-PATTERN: POST-003)
          # Only blocks NEW code in routers (legacy Db files are grandfathered)
          ACTOR_INPUT=""
          for file in $CHANGED_FILES; do
            if [[ "$file" == server/routers/* ]] && [ -f "$file" ]; then
              MATCH=$(grep -n "createdBy: input\." "$file" 2>/dev/null || true)
              if [ -n "$MATCH" ]; then
                ACTOR_INPUT="${ACTOR_INPUT}${file}:${MATCH}\n"
              fi
            fi
          done
          if [ -n "$ACTOR_INPUT" ]; then
            VIOLATIONS="${VIOLATIONS}### ❌ Actor Attribution from Input\n\nFound \`createdBy: input.createdBy\` - actor must come from \`ctx.user.id\`, not input.\n\n\`\`\`\n${ACTOR_INPUT}\`\`\`\n\n"
          fi

          # Save violations for comment
          if [ -n "$VIOLATIONS" ]; then
            echo "has_violations=true" >> $GITHUB_OUTPUT
            VIOLATIONS="${VIOLATIONS//'%'/'%25'}"
            VIOLATIONS="${VIOLATIONS//$'\n'/'%0A'}"
            VIOLATIONS="${VIOLATIONS//$'\r'/'%0D'}"
            echo "violations=${VIOLATIONS}" >> $GITHUB_OUTPUT
          else
            echo "has_violations=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for Hotfix Bypass
        id: check_hotfix
        run: |
          if [[ "${{ github.event.pull_request.title }}" == *"[HOTFIX]"* ]]; then
            echo "is_hotfix=true" >> $GITHUB_OUTPUT
          else
            echo "is_hotfix=false" >> $GITHUB_OUTPUT
          fi

      - name: Check Test Status
        id: check_status
        run: |
          TASK_ID="${{ steps.extract_task.outputs.task_id }}"
          if [ -z "$TASK_ID" ]; then
            echo "status=no_task_id" >> $GITHUB_OUTPUT
            exit 0
          fi

          ROADMAP_FILE=""
          if grep -q "${TASK_ID}" docs/roadmaps/MASTER_ROADMAP.md; then
            ROADMAP_FILE="docs/roadmaps/MASTER_ROADMAP.md"
          elif grep -q "${TASK_ID}" docs/roadmaps/TESTING_ROADMAP.md; then
            echo "status=testing_task" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "status=not_found" >> $GITHUB_OUTPUT
            exit 0
          fi

          TASK_LINE=$(grep "${TASK_ID}" "$ROADMAP_FILE")
          if echo "$TASK_LINE" | grep -q "Test Status: ✅ Fully Tested"; then
            echo "status=fully_tested" >> $GITHUB_OUTPUT
          elif echo "$TASK_LINE" | grep -q "Test Status: ⚪ Untested"; then
            echo "status=untested" >> $GITHUB_OUTPUT
          else
            echo "status=no_status_field" >> $GITHUB_OUTPUT
          fi

      - name: Post Status Comment
        uses: actions/github-script@v7
        with:
          script: |
            const isHotfix = '${{ steps.check_hotfix.outputs.is_hotfix }}' === 'true';
            const status = '${{ steps.check_status.outputs.status }}';
            const taskId = '${{ steps.extract_task.outputs.task_id }}';
            const hasViolations = '${{ steps.security_check.outputs.has_violations }}' === 'true';
            const violations = decodeURIComponent('${{ steps.security_check.outputs.violations }}' || '');

            let sections = [];

            // Security section (BLOCKING if violations found)
            if (hasViolations) {
              sections.push(`## ❌ Security Pattern Violations\n\n${violations}\n\n**This PR will be blocked until these patterns are fixed.**`);
            } else {
              sections.push(`## ✅ Security Patterns\n\nNo forbidden security patterns detected.`);
            }

            // Roadmap section (advisory)
            let roadmapSummary = "";
            if (isHotfix) {
              roadmapSummary = "✅ **Hotfix Bypass:** Roadmap checks bypassed.";
            } else if (status === 'fully_tested' || status === 'testing_task') {
              roadmapSummary = "✅ **PASS:** Feature is fully tested or is a testing task.";
            } else if (status === 'untested') {
              roadmapSummary = "⚠️ **WARNING:** Feature is untested. Consider adding tests.";
            } else if (status === 'no_task_id') {
              roadmapSummary = "⚠️ **INFO:** Could not extract Task ID from branch name.";
            } else if (status === 'not_found') {
              roadmapSummary = `⚠️ **INFO:** Task ${taskId} not found in roadmap.`;
            } else {
              roadmapSummary = `⚠️ **INFO:** Test status unknown. Proceed with review.`;
            }
            sections.push(`## Roadmap Status\n\n${roadmapSummary}`);

            const body = `# Pre-Merge Quality Gate\n\n${sections.join('\n\n---\n\n')}`;

            const [ownerFromEnv, repoFromEnv] = (process.env.GITHUB_REPOSITORY || "").split("/");
            const owner =
              context.repo.owner ||
              context.payload?.repository?.owner?.login ||
              ownerFromEnv;
            const repo =
              context.repo.repo ||
              context.repo.name ||
              context.payload?.repository?.name ||
              repoFromEnv;

            if (!owner || !repo) {
              core.warning("Skipping quality gate comment: unable to resolve owner/repo from workflow context.");
              return;
            }

            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner,
                repo,
                body: body
              });
            } catch (error) {
              core.warning(`Quality gate comment failed: ${error.message}`);
            }

      # Block merge if security violations found
      - name: Block on Security Violations
        if: steps.security_check.outputs.has_violations == 'true' && steps.check_hotfix.outputs.is_hotfix != 'true'
        run: |
          echo "❌ Security pattern violations detected. PR blocked."
          echo "Fix the patterns listed in the PR comment before merging."
          exit 1

  critical-interactions:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root_password
          MYSQL_DATABASE: terp_test
          MYSQL_USER: terp_test
          MYSQL_PASSWORD: terp_test_password
        ports:
          - 3307:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      DATABASE_URL: mysql://terp_test:terp_test_password@localhost:3307/terp_test

    steps:
      - uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: TypeScript check
        run: pnpm check

      - name: Lint changed files
        run: |
          CHANGED=$(git diff --name-only origin/main...HEAD -- '*.ts' '*.tsx' 2>/dev/null || true)
          if [ -n "$CHANGED" ]; then
            echo "$CHANGED" | xargs pnpm eslint --max-warnings=0 || true
          fi

      - name: Wait for MySQL
        run: |
          MAX_ATTEMPTS=30
          ATTEMPTS=0
          until mysqladmin ping -h 127.0.0.1 -P 3307 --silent 2>/dev/null; do
            ATTEMPTS=$((ATTEMPTS + 1))
            if [ "$ATTEMPTS" -ge "$MAX_ATTEMPTS" ]; then
              echo "MySQL failed to start after $MAX_ATTEMPTS attempts"
              exit 1
            fi
            sleep 2
          done

      - name: Push schema and seed
        run: pnpm drizzle-kit push --force && pnpm seed:light

      - name: Unit tests
        run: pnpm test --run

      - name: Install Playwright
        run: pnpm exec playwright install --with-deps

      - name: Run critical-path E2E tests
        run: pnpm exec playwright test tests-e2e/critical-paths/ --reporter=list
        env:
          CI: true

      - name: Upload Playwright report on failure
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: critical-paths-report
          path: playwright-report/
          retention-days: 7
