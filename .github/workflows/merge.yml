name: Main Branch CI/CD

on:
  push:
    branches: [main]

permissions:
  contents: write
  pull-requests: write
  issues: write
  discussions: write

env:
  DATABASE_URL: mysql://terp_test:terp_test_password@localhost:3307/terp_test
  ARGOS_TOKEN: ${{ secrets.ARGOS_TOKEN }}

jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root_password
          MYSQL_DATABASE: terp_test
          MYSQL_USER: terp_test
          MYSQL_PASSWORD: terp_test_password
        ports:
          - 3307:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10.4.1
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Push database schema
        id: schema
        run: |
          echo "Pushing database schema..."
          pnpm drizzle-kit push 2>&1 | tee schema-output.txt || {
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "status=passed" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: Seed test database
        id: seed
        run: |
          echo "Seeding test database..."
          pnpm seed:light 2>&1 | tee seed-output.txt || {
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "status=passed" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: Run integration tests
        id: integration
        run: |
          echo "Running integration tests..."
          pnpm test -- --config vitest.config.integration.ts --run --coverage --reporter=verbose 2>&1 | tee integration-output.txt || {
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "status=passed" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps
      
      - name: Run E2E tests with Argos
        id: e2e
        run: |
          echo "Running E2E tests..."
          CI=true pnpm playwright test 2>&1 | tee e2e-output.txt || {
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "status=passed" >> $GITHUB_OUTPUT
        env:
          CI: true
        continue-on-error: true
      
      - name: Upload Playwright report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
        continue-on-error: true
      
      - name: Check test coverage
        id: coverage
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            COVERAGE=$(cat coverage/coverage-summary.json | jq '.total.lines.pct')
            echo "Test coverage: $COVERAGE%"
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            if (( $(echo "$COVERAGE < 80" | bc -l) )); then
              echo "‚ùå Test coverage is below 80%"
              echo "status=warning" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ Test coverage is above 80%"
              echo "status=passed" >> $GITHUB_OUTPUT
            fi
          else
            echo "No coverage report found"
            echo "status=skipped" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true
      
      - name: Post Results Comment
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            const steps = {
              schema: '${{ steps.schema.outputs.status }}',
              seed: '${{ steps.seed.outputs.status }}',
              integration: '${{ steps.integration.outputs.status }}',
              e2e: '${{ steps.e2e.outputs.status }}',
              coverage: '${{ steps.coverage.outputs.status }}'
            };
            
            const coveragePct = '${{ steps.coverage.outputs.coverage }}';
            
            let allPassed = steps.schema === 'passed' && 
                           steps.seed === 'passed' && 
                           steps.integration === 'passed' && 
                           steps.e2e === 'passed';
            
            let body = allPassed ? '## ‚úÖ All Tests Passed\n\n' : '## ‚ùå Tests Failed\n\n';
            body += `**Commit:** \`${context.sha.substring(0, 7)}\`\n`;
            body += `**Branch:** \`main\`\n\n`;
            body += '---\n\n';
            
            // Schema push results
            body += steps.schema === 'passed' ? '**Database Schema:** ‚úÖ Pushed\n' : '**Database Schema:** ‚ùå Failed\n';
            if (steps.schema === 'failed' && fs.existsSync('schema-output.txt')) {
              const output = fs.readFileSync('schema-output.txt', 'utf8');
              const lastLines = output.split('\n').slice(-30).join('\n');
              body += '<details><summary>View schema errors</summary>\n\n```\n' + lastLines + '\n```\n</details>\n\n';
            }
            
            // Seed results
            body += steps.seed === 'passed' ? '**Database Seed:** ‚úÖ Completed\n' : '**Database Seed:** ‚ùå Failed\n';
            if (steps.seed === 'failed' && fs.existsSync('seed-output.txt')) {
              const output = fs.readFileSync('seed-output.txt', 'utf8');
              const lastLines = output.split('\n').slice(-30).join('\n');
              body += '<details><summary>View seed errors</summary>\n\n```\n' + lastLines + '\n```\n</details>\n\n';
            }
            
            // Integration test results
            body += steps.integration === 'passed' ? '**Integration Tests:** ‚úÖ Passed\n' : '**Integration Tests:** ‚ùå Failed\n';
            if (steps.integration === 'failed' && fs.existsSync('integration-output.txt')) {
              const output = fs.readFileSync('integration-output.txt', 'utf8');
              const lastLines = output.split('\n').slice(-100).join('\n');
              body += '<details><summary>View integration test failures</summary>\n\n```\n' + lastLines + '\n```\n</details>\n\n';
            }
            
            // E2E test results
            body += steps.e2e === 'passed' ? '**E2E Tests:** ‚úÖ Passed\n' : '**E2E Tests:** ‚ùå Failed\n';
            if (steps.e2e === 'failed' && fs.existsSync('e2e-output.txt')) {
              const output = fs.readFileSync('e2e-output.txt', 'utf8');
              const lastLines = output.split('\n').slice(-100).join('\n');
              body += '<details><summary>View E2E test failures</summary>\n\n```\n' + lastLines + '\n```\n</details>\n\n';
            }
            
            // Coverage
            if (coveragePct) {
              body += `**Test Coverage:** ${coveragePct}%\n\n`;
            }
            
            body += '---\n\n';
            
            if (!allPassed) {
              body += '## üö® Action Required\n\n';
              body += 'The main branch build has failed. **All agents must stop work immediately** and check this status.\n\n';
              body += '**How to check this via GitHub CLI:**\n';
              body += '```bash\n';
              body += '# View this commit\'s status\n';
              body += 'gh api repos/EvanTenenbaum/TERP/commits/' + context.sha + '/comments\n\n';
              body += '# View the workflow run\n';
              body += 'gh run view ${{ github.run_id }}\n\n';
              body += '# View recent workflow runs\n';
              body += 'gh run list --limit 5\n';
              body += '```\n\n';
              body += '**What to do:**\n';
              body += '1. Read the error details in the dropdowns above\n';
              body += '2. Pull the latest changes: `git pull origin main`\n';
              body += '3. Run the failing tests locally\n';
              body += '4. Fix the issues\n';
              body += '5. Create a PR with the fix\n\n';
              body += '**Do not push more changes to main until this is fixed.**';
            } else {
              body += '## üéâ Build Successful\n\n';
              body += 'All tests passed! The main branch is healthy.\n\n';
              body += 'üì∏ [View visual changes in Argos](https://app.argos-ci.com/EvanTenenbaum/TERP)';
            }
            
            // Write build status to a file for agent verification
            const statusFile = '.github/BUILD_STATUS.md';
            const timestamp = new Date().toISOString();
            
            const statusContent = `# Latest Build Status\n\n` +
              `**Last Updated:** ${timestamp}\n` +
              `**Commit:** \`${context.sha}\`\n` +
              `**Status:** ${allPassed ? '‚úÖ SUCCESS' : '‚ùå FAILED'}\n\n` +
              body;
            
            fs.writeFileSync(statusFile, statusContent);
            console.log('‚úÖ Wrote build status to', statusFile);
            
            // Try to post commit comment (best effort)
            try {
              const comment = await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.name,
                commit_sha: context.sha,
                body: body
              });
              console.log('‚úÖ Posted commit comment:', comment.data.html_url);
            } catch (error) {
              console.warn('‚ö†Ô∏è Could not post commit comment:', error.message);
              console.log('Build status is available in', statusFile);
            }
      
      - name: Update build status on separate branch
        if: always()
        run: |
          # Push build status to a separate branch to avoid triggering DigitalOcean deployments
          # DigitalOcean only monitors 'main' branch, so this won't trigger deployments
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Fetch to ensure we have remote branches
          git fetch origin build-status:build-status 2>/dev/null || true
          
          # Checkout build-status branch (create if it doesn't exist)
          if git show-ref --verify --quiet refs/heads/build-status; then
            git checkout build-status
            git merge main --no-edit -m "Merge main into build-status" || true
          else
            git checkout -b build-status
          fi
          
          # Copy the updated BUILD_STATUS.md from main
          git checkout main -- .github/BUILD_STATUS.md 2>/dev/null || true
          git add .github/BUILD_STATUS.md || true
          
          if ! git diff --staged --quiet; then
            git commit -m "Update build status [skip ci]" || true
            git push origin build-status || echo "Failed to push build status branch"
          else
            echo "No changes to BUILD_STATUS.md"
          fi
          
          # Return to main branch for any subsequent steps
          git checkout main
      
      - name: Create fallback issue if comment failed
        uses: actions/github-script@v7
        if: failure() && steps.schema.outputs.status != ''
        with:
          script: |
            const steps = {
              schema: '${{ steps.schema.outputs.status }}',
              seed: '${{ steps.seed.outputs.status }}',
              integration: '${{ steps.integration.outputs.status }}',
              e2e: '${{ steps.e2e.outputs.status }}',
            };
            
            let allPassed = steps.schema === 'passed' && 
                           steps.seed === 'passed' && 
                           steps.integration === 'passed' && 
                           steps.e2e === 'passed';
            
            const title = allPassed 
              ? `‚úÖ Build ${context.sha.substring(0, 7)} succeeded (comment posting failed)`
              : `‚ùå Build ${context.sha.substring(0, 7)} failed`;
            
            const body = `## Build Status Notification\n\n` +
              `‚ö†Ô∏è **This issue was created because the automated commit comment failed to post.**\n\n` +
              `**Commit:** \`${context.sha}\`\n` +
              `**Branch:** \`main\`\n` +
              `**Workflow Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n` +
              `### Test Results\n\n` +
              `- Database Schema: ${steps.schema === 'passed' ? '‚úÖ' : '‚ùå'} ${steps.schema}\n` +
              `- Database Seed: ${steps.seed === 'passed' ? '‚úÖ' : '‚ùå'} ${steps.seed}\n` +
              `- Integration Tests: ${steps.integration === 'passed' ? '‚úÖ' : '‚ùå'} ${steps.integration}\n` +
              `- E2E Tests: ${steps.e2e === 'passed' ? '‚úÖ' : '‚ùå'} ${steps.e2e}\n\n` +
              `**Action Required:** Fix the workflow permissions to allow commit comments.`;
            
            try {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.name,
                title: title,
                body: body,
                labels: ['ci/cd', 'automated']
              });
              console.log('‚úÖ Created fallback issue for build status');
            } catch (error) {
              console.error('‚ùå Failed to create fallback issue:', error.message);
            }
      
      - name: Fail if any test failed
        if: steps.schema.outputs.status == 'failed' || steps.seed.outputs.status == 'failed' || steps.integration.outputs.status == 'failed' || steps.e2e.outputs.status == 'failed'
        run: |
          echo "‚ùå One or more tests failed. See the commit comment for details."
          exit 1
      
      - name: Deploy to staging (placeholder)
        if: success()
        run: echo "Deployment step would go here"
        # Add your deployment logic here (e.g., Railway, DigitalOcean, etc.)
