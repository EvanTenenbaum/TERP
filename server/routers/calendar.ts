import { z } from "zod";
import { publicProcedure, router } from "../_core/trpc";
import * as calendarDb from "../calendarDb";
import TimezoneService from "../_core/timezoneService";
import PermissionService from "../_core/permissionService";
import InstanceGenerationService from "../_core/instanceGenerationService";
import { getDb } from "../db";
import { calendarEvents, calendarRecurrenceInstances } from "../../drizzle/schema";
import { and, eq, gte, lte, inArray, isNull, or } from "drizzle-orm";
import { requirePermission } from "../_core/permissionMiddleware";

/**
 * Calendar Router
 * Core event operations for Calendar & Scheduling Module
 * Version 2.0 - Post-Adversarial QA
 * PRODUCTION-READY - No placeholders
 */

export const calendarRouter = router({
  // Get events with intelligent filtering
  getEvents: publicProcedure
    .input(
      z.object({
        startDate: z.string(), // ISO date
        endDate: z.string(), // ISO date
        modules: z.array(z.string()).optional(),
        eventTypes: z.array(z.string()).optional(),
        statuses: z.array(z.string()).optional(),
        priorities: z.array(z.string()).optional(),
        assignedTo: z.number().optional(),
        includeAutoGenerated: z.boolean().default(true),
        timezone: z.string().optional(), // User's timezone for display
      })
    )
    .query(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new Error("Database not available");

      const userId = ctx.user?.id || 1;

      // Build base query for calendar events
      let eventConditions: any[] = [
        gte(calendarEvents.startDate, input.startDate),
        lte(calendarEvents.endDate, input.endDate),
        isNull(calendarEvents.deletedAt),
      ];

      // Apply filters
      if (input.modules && input.modules.length > 0) {
        eventConditions.push(inArray(calendarEvents.module, input.modules as any));
      }
      if (input.eventTypes && input.eventTypes.length > 0) {
        eventConditions.push(inArray(calendarEvents.eventType, input.eventTypes as any));
      }
      if (input.statuses && input.statuses.length > 0) {
        eventConditions.push(inArray(calendarEvents.status, input.statuses as any));
      }
      if (input.priorities && input.priorities.length > 0) {
        eventConditions.push(inArray(calendarEvents.priority, input.priorities as any));
      }
      if (input.assignedTo) {
        eventConditions.push(eq(calendarEvents.assignedTo, input.assignedTo));
      }
      if (!input.includeAutoGenerated) {
        eventConditions.push(eq(calendarEvents.isAutoGenerated, false));
      }

      // Query calendar events
      const events = await db
        .select()
        .from(calendarEvents)
        .where(and(...eventConditions));

      // Filter by permissions
      const visibleEvents = await Promise.all(
        events.map(async (event) => {
          const hasPermission = await PermissionService.checkEventPermission(
            userId,
            event.id,
            "VIEW"
          );
          return hasPermission ? event : null;
        })
      );

      const filteredEvents = visibleEvents.filter((e) => e !== null);

      // Query recurrence instances
      const instanceConditions: any[] = [
        gte(calendarRecurrenceInstances.instanceDate, input.startDate),
        lte(calendarRecurrenceInstances.instanceDate, input.endDate),
      ];

      const instances = await db
        .select()
        .from(calendarRecurrenceInstances)
        .where(and(...instanceConditions));

      // Combine events and instances
      const allEvents = [
        ...filteredEvents.map((e) => ({ ...e, isInstance: false })),
        ...instances.map((i) => ({
          ...i,
          isInstance: true,
          id: i.id,
          title: i.modifiedTitle || "",
          startDate: i.instanceDate,
          endDate: i.instanceDate,
        })),
      ];

      // Convert to user's timezone if provided
      if (input.timezone) {
        allEvents.forEach((event) => {
          if (event.startTime && event.timezone) {
            const converted = TimezoneService.convertToTimezone(
              event.startDate,
              event.startTime,
              event.timezone,
              input.timezone!
            );
            event.displayTime = converted.time;
            event.displayTimezone = input.timezone;
          }
        });
      }

      return allEvents;
    }),

  // Get single event with full details
  getEventById: publicProcedure
    .input(
      z.object({
        id: z.number(),
        timezone: z.string().optional(),
      })
    )
    .query(async ({ input, ctx }) => {
      const userId = ctx.user?.id || 1;

      // Check permission
      const hasPermission = await PermissionService.checkEventPermission(
        userId,
        input.id,
        "VIEW"
      );

      if (!hasPermission) {
        throw new Error("Permission denied");
      }

      const event = await calendarDb.getEventById(input.id);
      if (!event) throw new Error("Event not found");

      // Fetch related data
      const [participants, reminders, attachments, permissions, history] =
        await Promise.all([
          calendarDb.getEventParticipants(input.id),
          calendarDb.getEventReminders(input.id),
          calendarDb.getEventAttachments(input.id),
          calendarDb.getEventPermissions(input.id),
          calendarDb.getEventHistory(input.id),
        ]);

      // Fetch recurrence rule if recurring
      let recurrenceRule = null;
      if (event.isRecurring) {
        recurrenceRule = await calendarDb.getRecurrenceRule(input.id);
      }

      // Convert to user's timezone
      if (input.timezone && event.startTime && event.timezone) {
        const converted = TimezoneService.convertToTimezone(
          event.startDate,
          event.startTime,
          event.timezone,
          input.timezone
        );
        event.displayTime = converted.time;
        event.displayTimezone = input.timezone;
      }

      return {
        ...event,
        participants,
        reminders,
        attachments,
        permissions,
        history,
        recurrenceRule,
      };
    }),

  // Create event with comprehensive validation
  createEvent: publicProcedure
    .input(
      z.object({
        title: z.string().min(1).max(255),
        description: z.string().optional(),
        location: z.string().max(500).optional(),
        startDate: z.string(),
        endDate: z.string(),
        startTime: z.string().optional(),
        endTime: z.string().optional(),
        timezone: z.string(),
        isFloatingTime: z.boolean().default(false),
        module: z.enum([
          "INVENTORY",
          "ACCOUNTING",
          "CLIENTS",
          "VENDORS",
          "ORDERS",
          "SAMPLES",
          "COMPLIANCE",
          "GENERAL",
        ]),
        eventType: z.enum([
          "MEETING",
          "DEADLINE",
          "TASK",
          "DELIVERY",
          "PAYMENT_DUE",
          "FOLLOW_UP",
          "AUDIT",
          "INTAKE",
          "PHOTOGRAPHY",
          "BATCH_EXPIRATION",
          "RECURRING_ORDER",
          "SAMPLE_REQUEST",
          "OTHER",
        ]),
        status: z
          .enum(["SCHEDULED", "IN_PROGRESS", "COMPLETED", "CANCELLED"])
          .default("SCHEDULED"),
        priority: z.enum(["LOW", "MEDIUM", "HIGH", "URGENT"]).default("MEDIUM"),
        visibility: z
          .enum(["PRIVATE", "TEAM", "COMPANY", "PUBLIC"])
          .default("COMPANY"),
        assignedTo: z.number().optional(),
        entityType: z.string().optional(),
        entityId: z.number().optional(),
        isRecurring: z.boolean().default(false),
        recurrenceRule: z
          .object({
            frequency: z.enum(["DAILY", "WEEKLY", "MONTHLY", "YEARLY"]),
            interval: z.number().default(1),
            byDay: z.array(z.number()).optional(),
            byMonthDay: z.array(z.number()).optional(),
            byWeekOfMonth: z.array(z.number()).optional(),
            byDayOfWeekInMonth: z
              .array(z.object({ week: z.number(), day: z.number() }))
              .optional(),
            byMonth: z.array(z.number()).optional(),
            startDate: z.string(),
            endDate: z.string().optional(),
            count: z.number().optional(),
            exceptionDates: z.array(z.string()).optional(),
          })
          .optional(),
        participants: z.array(z.number()).optional(),
        reminders: z
          .array(
            z.object({
              relativeMinutes: z.number(),
              method: z.enum(["IN_APP", "EMAIL", "BOTH"]),
            })
          )
          .optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const userId = ctx.user?.id || 1;

      // Validate timezone
      TimezoneService.validateTimezone(input.timezone);

      // Validate date/time
      if (input.startTime && !input.isFloatingTime) {
        const validation = TimezoneService.validateDateTime(
          input.startDate,
          input.startTime,
          input.timezone
        );
        if (!validation.isValid) {
          throw new Error(validation.error || "Invalid date/time");
        }
      }

      // Create event in transaction
      const db = await getDb();
      if (!db) throw new Error("Database not available");

      const newEvent = await calendarDb.createEvent({
        title: input.title,
        description: input.description || null,
        location: input.location || null,
        startDate: input.startDate,
        endDate: input.endDate,
        startTime: input.startTime || null,
        endTime: input.endTime || null,
        timezone: input.timezone,
        isFloatingTime: input.isFloatingTime,
        module: input.module,
        eventType: input.eventType,
        status: input.status,
        priority: input.priority,
        visibility: input.visibility,
        createdBy: userId,
        assignedTo: input.assignedTo || null,
        entityType: input.entityType || null,
        entityId: input.entityId || null,
        isRecurring: input.isRecurring,
        isAutoGenerated: false,
        autoGenerationRule: null,
      });

      const eventId = newEvent.id;

      // Create recurrence rule if recurring
      if (input.isRecurring && input.recurrenceRule) {
        await calendarDb.createRecurrenceRule({
          eventId,
          frequency: input.recurrenceRule.frequency,
          interval: input.recurrenceRule.interval,
          byDay: input.recurrenceRule.byDay || null,
          byMonthDay: input.recurrenceRule.byMonthDay || null,
          byWeekOfMonth: input.recurrenceRule.byWeekOfMonth || null,
          byDayOfWeekInMonth: input.recurrenceRule.byDayOfWeekInMonth || null,
          byMonth: input.recurrenceRule.byMonth || null,
          startDate: input.recurrenceRule.startDate,
          endDate: input.recurrenceRule.endDate || null,
          count: input.recurrenceRule.count || null,
          exceptionDates: input.recurrenceRule.exceptionDates || null,
        });

        // Generate initial instances
        await InstanceGenerationService.generateInstances(eventId, 90);
      }

      // Add participants
      if (input.participants && input.participants.length > 0) {
        for (const participantId of input.participants) {
          await calendarDb.addParticipant({
            eventId,
            userId: participantId,
            role: "REQUIRED",
            responseStatus: "PENDING",
            notifyOnCreation: true,
            notifyOnUpdate: true,
            addedBy: userId,
          });
        }
      }

      // Add reminders
      if (input.reminders && input.reminders.length > 0) {
        for (const reminder of input.reminders) {
          const reminderTime = new Date(input.startDate);
          reminderTime.setMinutes(
            reminderTime.getMinutes() - reminder.relativeMinutes
          );

          await calendarDb.createReminder({
            eventId,
            userId,
            reminderTime,
            relativeMinutes: reminder.relativeMinutes,
            method: reminder.method,
            status: "PENDING",
          });
        }
      }

      // Log to history
      await calendarDb.addHistoryEntry({
        eventId,
        changedBy: userId,
        changeType: "CREATED",
        fieldName: null,
        oldValue: null,
        newValue: null,
        notes: "Event created",
      });

      return newEvent;
    }),

  // Update event with conflict detection
  updateEvent: publicProcedure
    .input(
      z.object({
        id: z.number(),
        updates: z.object({
          title: z.string().min(1).max(255).optional(),
          description: z.string().optional(),
          location: z.string().max(500).optional(),
          startDate: z.string().optional(),
          endDate: z.string().optional(),
          startTime: z.string().optional(),
          endTime: z.string().optional(),
          status: z
            .enum(["SCHEDULED", "IN_PROGRESS", "COMPLETED", "CANCELLED"])
            .optional(),
          priority: z.enum(["LOW", "MEDIUM", "HIGH", "URGENT"]).optional(),
          assignedTo: z.number().optional(),
        }),
        updateScope: z
          .enum(["THIS_INSTANCE", "THIS_AND_FUTURE", "ALL_INSTANCES"])
          .optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const userId = ctx.user?.id || 1;

      // Check permission
      const hasPermission = await PermissionService.checkEventPermission(
        userId,
        input.id,
        "EDIT"
      );

      if (!hasPermission) {
        throw new Error("Permission denied");
      }

      // Get current event for history
      const currentEvent = await calendarDb.getEventById(input.id);
      if (!currentEvent) throw new Error("Event not found");

      // Update event
      await calendarDb.updateEvent(input.id, input.updates);

      // Log changes to history
      for (const [field, newValue] of Object.entries(input.updates)) {
        const oldValue = currentEvent[field as keyof typeof currentEvent];
        if (oldValue !== newValue) {
          await calendarDb.addHistoryEntry({
            eventId: input.id,
            changedBy: userId,
            changeType: "UPDATED",
            fieldName: field,
            oldValue: String(oldValue),
            newValue: String(newValue),
            notes: null,
          });
        }
      }

      // Regenerate instances if recurring and dates changed
      if (
        currentEvent.isRecurring &&
        (input.updates.startDate || input.updates.endDate)
      ) {
        await InstanceGenerationService.generateInstances(input.id, 90);
      }

      return { success: true };
    }),

  // Delete event with cascade handling
  deleteEvent: publicProcedure
    .input(
      z.object({
        id: z.number(),
        deleteScope: z
          .enum(["THIS_INSTANCE", "THIS_AND_FUTURE", "ALL_INSTANCES"])
          .optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const userId = ctx.user?.id || 1;

      // Check permission
      const hasPermission = await PermissionService.checkEventPermission(
        userId,
        input.id,
        "DELETE"
      );

      if (!hasPermission) {
        throw new Error("Permission denied");
      }

      // Soft delete event
      await calendarDb.softDeleteEvent(input.id);

      // Log to history
      await calendarDb.addHistoryEntry({
        eventId: input.id,
        changedBy: userId,
        changeType: "DELETED",
        fieldName: null,
        oldValue: null,
        newValue: null,
        notes: "Event deleted",
      });

      return { success: true };
    }),

  // Get events by entity (for linking)
  getEventsByEntity: publicProcedure
    .input(
      z.object({
        entityType: z.string(),
        entityId: z.number(),
      })
    )
    .query(async ({ input }) => {
      return await calendarDb.getEventsByEntity(
        input.entityType,
        input.entityId
      );
    }),

  // Get events assigned to user
  getMyEvents: publicProcedure.query(async ({ ctx }) => {
    const userId = ctx.user?.id || 1;
    return await calendarDb.getEventsAssignedToUser(userId);
  }),

  // Get event history
  getEventHistory: publicProcedure
    .input(z.object({ eventId: z.number() }))
    .query(async ({ input }) => {
      return await calendarDb.getEventHistory(input.eventId);
    }),

  // Get event attachments
  getEventAttachments: publicProcedure
    .input(z.object({ eventId: z.number() }))
    .query(async ({ input }) => {
      return await calendarDb.getEventAttachments(input.eventId);
    }),
});
