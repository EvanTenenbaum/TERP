import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { publicProcedure, router, protectedProcedure, getAuthenticatedUserId } from "../_core/trpc";
import * as calendarDb from "../calendarDb";
import TimezoneService from "../_core/timezoneService";
import PermissionService from "../_core/permissionService";
import InstanceGenerationService from "../_core/instanceGenerationService";
import { getDb } from "../db";
import { calendarEvents, calendarRecurrenceInstances } from "../../drizzle/schema";
import { and, eq, gte, lte, inArray, isNull, or, sql } from "drizzle-orm";

/**
 * Calendar Router
 * Core event operations for Calendar & Scheduling Module
 * Version 2.0 - Post-Adversarial QA
 * PRODUCTION-READY - No placeholders
 */

export const calendarRouter = router({
  // Get events with intelligent filtering
  getEvents: publicProcedure
    .input(
      z.object({
        startDate: z.string(), // ISO date
        endDate: z.string(), // ISO date
        modules: z.array(z.string()).optional(),
        eventTypes: z.array(z.string()).optional(),
        statuses: z.array(z.string()).optional(),
        priorities: z.array(z.string()).optional(),
        assignedTo: z.number().optional(),
        includeAutoGenerated: z.boolean().default(true),
        timezone: z.string().optional(), // User's timezone for display
        // Pagination parameters
        limit: z.number().min(1).max(500).default(100).optional(),
        offset: z.number().min(0).default(0).optional(),
        includeTotalCount: z.boolean().default(false).optional(),
      })
    )
    .query(async ({ input, ctx }) => {
      const db = await getDb();
        if (!db) throw new Error("Database not available");
      if (!db) throw new Error("Database not available");

      // For read operations, allow public user but track it
      const userId = ctx.user?.id ?? 1;

      // Build base query for calendar events
      let eventConditions: any[] = [
        gte(calendarEvents.startDate, new Date(input.startDate)),
        lte(calendarEvents.endDate, new Date(input.endDate)),
        isNull(calendarEvents.deletedAt),
      ];

      // Apply filters
      if (input.modules && input.modules.length > 0) {
        eventConditions.push(inArray(calendarEvents.module, input.modules as any));
      }
      if (input.eventTypes && input.eventTypes.length > 0) {
        eventConditions.push(inArray(calendarEvents.eventType, input.eventTypes as any));
      }
      if (input.statuses && input.statuses.length > 0) {
        eventConditions.push(inArray(calendarEvents.status, input.statuses as any));
      }
      if (input.priorities && input.priorities.length > 0) {
        eventConditions.push(inArray(calendarEvents.priority, input.priorities as any));
      }
      if (input.assignedTo) {
        eventConditions.push(eq(calendarEvents.assignedTo, input.assignedTo));
      }
      if (!input.includeAutoGenerated) {
        eventConditions.push(eq(calendarEvents.isAutoGenerated, false));
      }

      // Get total count if requested (before pagination)
      let totalCount = 0;
      if (input.includeTotalCount) {
        const countResult = await db
          .select({ count: sql<number>`count(*)` })
          .from(calendarEvents)
          .where(and(...eventConditions));
        totalCount = countResult[0]?.count || 0;
      }

      // Query calendar events with pagination
      const limit = input.limit || 100;
      const offset = input.offset || 0;
      
      const events = await db
        .select()
        .from(calendarEvents)
        .where(and(...eventConditions))
        .limit(limit)
        .offset(offset);

      // Filter by permissions using batch check (fixes N+1 query problem)
      let filteredEvents = events;
      if (events.length > 0) {
        const eventIds = events.map((e) => e.id);
        const permissionMap = await PermissionService.batchCheckPermissions(
          userId,
          eventIds,
          "VIEW"
        );
        filteredEvents = events.filter((e) => permissionMap[e.id]);
      }

      // Query recurrence instances
      const instanceConditions: any[] = [
        gte(calendarRecurrenceInstances.instanceDate, new Date(input.startDate)),
        lte(calendarRecurrenceInstances.instanceDate, new Date(input.endDate)),
      ];

      const instances = await db
        .select()
        .from(calendarRecurrenceInstances)
        .where(and(...instanceConditions));

      // Combine events and instances
      const allEvents = [
        ...filteredEvents.map((e) => ({ ...e, isInstance: false })),
        ...instances.map((i) => ({
          ...i,
          isInstance: true,
          id: i.id,
          title: i.modifiedTitle || "",
          startDate: i.instanceDate,
          endDate: i.instanceDate,
        })),
      ];

      // Convert to user's timezone if provided
      const eventsWithDisplay = allEvents.map((event) => {
        if (input.timezone && event.startTime && event.timezone) {
          const dateStr = event.startDate instanceof Date 
            ? event.startDate.toISOString().split('T')[0] 
            : String(event.startDate);
          const converted = TimezoneService.convertTimezone(
            dateStr,
            event.startTime,
            event.timezone,
            input.timezone!
          );
          return {
            ...event,
            displayTime: converted.time,
            displayTimezone: input.timezone,
          };
        }
        return {
          ...event,
          displayTime: null as string | null,
          displayTimezone: null as string | null,
        };
      });

      // Return with pagination metadata if requested
      if (input.includeTotalCount) {
        return {
          data: eventsWithDisplay,
          pagination: {
            total: totalCount,
            limit: limit,
            offset: offset,
            hasMore: offset + eventsWithDisplay.length < totalCount,
          },
        };
      }

      return eventsWithDisplay;
    }),

  // Get single event with full details
  getEventById: publicProcedure
    .input(
      z.object({
        id: z.number(),
        timezone: z.string().optional(),
      })
    )
    .query(async ({ input, ctx }) => {
      // For read operations, use authenticated user or reject
      const userId = getAuthenticatedUserId(ctx);

      // Check permission
      // Check if user has VIEW permission via requirePermission
      const hasPermission = await PermissionService.hasPermission(userId, input.id, "VIEW");

      if (!hasPermission) {
        throw new Error("Permission denied");
      }

      const event = await calendarDb.getEventById(input.id);
      if (!event) throw new Error("Event not found");

      // Fetch related data
      const [participants, reminders, attachments, permissions, history] =
        await Promise.all([
          calendarDb.getEventParticipants(input.id),
          calendarDb.getEventReminders(input.id),
          calendarDb.getEventAttachments(input.id),
          calendarDb.getEventPermissions(input.id),
          calendarDb.getEventHistory(input.id),
        ]);

      // Fetch recurrence rule if recurring
      let recurrenceRule = null;
      if (event.isRecurring) {
        recurrenceRule = await calendarDb.getRecurrenceRule(input.id);
      }

      // Convert to user's timezone
      let displayTime: string | null = null;
      let displayTimezone: string | null = null;
      if (input.timezone && event.startTime && event.timezone) {
        const dateStr = event.startDate instanceof Date 
          ? event.startDate.toISOString().split('T')[0] 
          : String(event.startDate);
        const converted = TimezoneService.convertTimezone(
          dateStr,
          event.startTime,
          event.timezone,
          input.timezone
        );
        displayTime = converted.time;
        displayTimezone = input.timezone;
      }

      return {
        ...event,
        displayTime,
        displayTimezone,
        participants,
        reminders,
        attachments,
        permissions,
        history,
        recurrenceRule,
      };
    }),

  // Create event with comprehensive validation
  createEvent: publicProcedure
    .input(
      z.object({
        title: z.string().min(1).max(255),
        description: z.string().optional(),
        location: z.string().max(500).optional(),
        startDate: z.string(),
        endDate: z.string(),
        startTime: z.string().optional(),
        endTime: z.string().optional(),
        timezone: z.string(),
        isFloatingTime: z.boolean().default(false),
        module: z.enum([
          "INVENTORY",
          "ACCOUNTING",
          "CLIENTS",
          "VENDORS",
          "ORDERS",
          "SAMPLES",
          "COMPLIANCE",
          "GENERAL",
        ]),
        eventType: z.enum([
          "MEETING",
          "TASK",
          "DELIVERY",
          "PAYMENT_DUE",
          "FOLLOW_UP",
          "AUDIT",
          "INTAKE",
          "PHOTOGRAPHY",
          "BATCH_EXPIRATION",
          "RECURRING_ORDER",
          "SAMPLE_REQUEST",
          "OTHER",
        ]),
        status: z
          .enum(["SCHEDULED", "IN_PROGRESS", "COMPLETED", "CANCELLED"])
          .default("SCHEDULED"),
        priority: z.enum(["LOW", "MEDIUM", "HIGH", "URGENT"]).default("MEDIUM"),
        visibility: z
          .enum(["PRIVATE", "TEAM", "COMPANY", "PUBLIC"])
          .default("COMPANY"),
        assignedTo: z.number().optional(),
        entityType: z.string().optional(),
        entityId: z.number().optional(),
        clientId: z.number().optional(),
        isRecurring: z.boolean().default(false),
        recurrenceRule: z
          .object({
            frequency: z.enum(["DAILY", "WEEKLY", "MONTHLY", "YEARLY"]),
            interval: z.number().default(1),
            byDay: z.array(z.number()).optional(),
            byMonthDay: z.array(z.number()).optional(),
            byWeekOfMonth: z.array(z.number()).optional(),
            byDayOfWeekInMonth: z
              .array(z.object({ week: z.number(), day: z.number() }))
              .optional(),
            byMonth: z.array(z.number()).optional(),
            startDate: z.string(),
            endDate: z.string().optional(),
            count: z.number().optional(),
            exceptionDates: z.array(z.string()).optional(),
          })
          .optional(),
        participants: z.array(z.number()).optional(),
        reminders: z
          .array(
            z.object({
              relativeMinutes: z.number(),
              method: z.enum(["IN_APP", "EMAIL", "BOTH"]),
            })
          )
          .optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const userId = getAuthenticatedUserId(ctx);

      // Validate timezone
      TimezoneService.validateTimezone(input.timezone);

      // Validate date/time (throws error if invalid)
      if (input.startTime && !input.isFloatingTime) {
        TimezoneService.validateDateTime(
          input.startDate,
          input.startTime,
          input.timezone
        );
      }

      // Create event in transaction
      const db = await getDb();
      if (!db) throw new Error("Database not available");

      // CHAOS-010: Double-booking prevention
      // Check for overlapping events for the assignee and participants
      const usersToCheck: number[] = [];
      if (input.assignedTo) {
        usersToCheck.push(input.assignedTo);
      }
      if (input.participants && input.participants.length > 0) {
        usersToCheck.push(...input.participants.filter(p => !usersToCheck.includes(p)));
      }

      if (usersToCheck.length > 0 && input.startTime && input.endTime) {
        // Query for overlapping events
        const startDateTime = new Date(input.startDate);
        const endDateTime = new Date(input.endDate);

        const overlappingEvents = await db
          .select({
            id: calendarEvents.id,
            title: calendarEvents.title,
            startDate: calendarEvents.startDate,
            startTime: calendarEvents.startTime,
            endTime: calendarEvents.endTime,
            assignedTo: calendarEvents.assignedTo,
          })
          .from(calendarEvents)
          .where(
            and(
              isNull(calendarEvents.deletedAt),
              // Date overlap check
              or(
                // Event spans the same date
                and(
                  lte(calendarEvents.startDate, endDateTime),
                  gte(calendarEvents.endDate, startDateTime)
                )
              ),
              // Assigned to one of the users we're checking
              inArray(calendarEvents.assignedTo, usersToCheck)
            )
          );

        // Check for time overlap
        const conflictingEvents = overlappingEvents.filter(event => {
          if (!event.startTime || !event.endTime) return false;

          // Convert times to comparable format
          const newStart = input.startTime!;
          const newEnd = input.endTime!;
          const existingStart = event.startTime;
          const existingEnd = event.endTime;

          // Check for time overlap:
          // Events overlap if one starts before the other ends AND ends after the other starts
          return newStart < existingEnd && newEnd > existingStart;
        });

        if (conflictingEvents.length > 0) {
          const conflictInfo = conflictingEvents.map(e =>
            `"${e.title}" (${e.startTime}-${e.endTime})`
          ).join(', ');

          throw new TRPCError({
            code: "CONFLICT",
            message: `Double-booking detected: The assignee or participants already have events during this time: ${conflictInfo}. Please choose a different time slot.`,
          });
        }
      }

      const newEvent = await calendarDb.createEvent({
        title: input.title,
        description: input.description || null,
        location: input.location || null,
        startDate: new Date(input.startDate),
        endDate: new Date(input.endDate),
        startTime: input.startTime || null,
        endTime: input.endTime || null,
        timezone: input.timezone,
        isFloatingTime: input.isFloatingTime,
        module: input.module,
        eventType: input.eventType,
        status: input.status,
        priority: input.priority,
        visibility: input.visibility,
        createdBy: userId,
        assignedTo: input.assignedTo || null,
        entityType: input.entityType || null,
        entityId: input.entityId || null,
        clientId: input.clientId || null,
        isRecurring: input.isRecurring,
        isAutoGenerated: false,
        autoGenerationRule: null,
      });

      const eventId = newEvent.id;

      // Create recurrence rule if recurring
      if (input.isRecurring && input.recurrenceRule) {
        await calendarDb.createRecurrenceRule({
          eventId,
          frequency: input.recurrenceRule.frequency,
          interval: input.recurrenceRule.interval,
          byDay: input.recurrenceRule.byDay || null,
          byMonthDay: input.recurrenceRule.byMonthDay || null,
          byWeekOfMonth: input.recurrenceRule.byWeekOfMonth || null,
          byDayOfWeekInMonth: input.recurrenceRule.byDayOfWeekInMonth || null,
          byMonth: input.recurrenceRule.byMonth || null,
          startDate: new Date(input.recurrenceRule.startDate),
          endDate: input.recurrenceRule.endDate ? new Date(input.recurrenceRule.endDate) : null,
          count: input.recurrenceRule.count || null,
          exceptionDates: input.recurrenceRule.exceptionDates || null,
        });

        // Generate initial instances
        await InstanceGenerationService.generateInstances(eventId, 90);
      }

      // Add participants
      if (input.participants && input.participants.length > 0) {
        for (const participantId of input.participants) {
          await calendarDb.addParticipant({
            eventId,
            userId: participantId,
            role: "REQUIRED",
            responseStatus: "PENDING",
            notifyOnCreation: true,
            notifyOnUpdate: true,
            addedBy: userId,
          });
        }
      }

      // Add reminders
      if (input.reminders && input.reminders.length > 0) {
        for (const reminder of input.reminders) {
          const reminderTime = new Date(input.startDate);
          reminderTime.setMinutes(
            reminderTime.getMinutes() - reminder.relativeMinutes
          );

          await calendarDb.createReminder({
            eventId,
            userId,
            reminderTime,
            relativeMinutes: reminder.relativeMinutes,
            method: reminder.method,
            status: "PENDING",
          });
        }
      }

      // Log to history
      await calendarDb.addHistoryEntry({
        eventId,
        changedBy: userId,
        changeType: "CREATED",
        fieldChanged: null,
        previousValue: null,
        newValue: null,
        changeReason: "Event created",
      });

      return newEvent;
    }),

  // Update event with conflict detection and optimistic locking (CHAOS-006)
  updateEvent: publicProcedure
    .input(
      z.object({
        id: z.number(),
        version: z.number().optional(), // Optimistic locking - if provided, will check version before update
        updates: z.object({
          title: z.string().min(1).max(255).optional(),
          description: z.string().optional(),
          location: z.string().max(500).optional(),
          startDate: z.string().optional(),
          endDate: z.string().optional(),
          startTime: z.string().optional(),
          endTime: z.string().optional(),
          status: z
            .enum(["SCHEDULED", "IN_PROGRESS", "COMPLETED", "CANCELLED"])
            .optional(),
          priority: z.enum(["LOW", "MEDIUM", "HIGH", "URGENT"]).optional(),
          assignedTo: z.number().optional(),
          clientId: z.number().optional(),
        }),
        updateScope: z
          .enum(["THIS_INSTANCE", "THIS_AND_FUTURE", "ALL_INSTANCES"])
          .optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const db = await getDb();
      if (!db) throw new Error("Database not available");

      const userId = getAuthenticatedUserId(ctx);

      // Check permission
      const hasPermission = await PermissionService.hasPermission(userId, input.id, "EDIT");

      if (!hasPermission) {
        throw new Error("Permission denied");
      }

      // Get current event for history and version check
      const currentEvent = await calendarDb.getEventById(input.id);
      if (!currentEvent) throw new Error("Event not found");

      // CHAOS-006: Optimistic locking - check version if provided
      if (input.version !== undefined) {
        const currentVersion = (currentEvent as any).version ?? 1;
        if (currentVersion !== input.version) {
          throw new TRPCError({
            code: "CONFLICT",
            message: `This event has been modified by another user. Your version: ${input.version}, Current version: ${currentVersion}. Please refresh and try again.`,
          });
        }
      }

      // Convert string dates to Date objects for database
      const dbUpdates: Record<string, unknown> = { ...input.updates };
      if (input.updates.startDate) {
        dbUpdates.startDate = new Date(input.updates.startDate);
      }
      if (input.updates.endDate) {
        dbUpdates.endDate = new Date(input.updates.endDate);
      }

      // CHAOS-006: Increment version on update
      if (input.version !== undefined) {
        // Use version-aware update with WHERE clause
        const result = await db
          .update(calendarEvents)
          .set({
            ...dbUpdates,
            version: sql`${calendarEvents.version} + 1`,
          } as any)
          .where(
            and(
              eq(calendarEvents.id, input.id),
              eq(calendarEvents.version, input.version)
            )
          );

        const affectedRows = (result as any)[0]?.affectedRows ?? 0;
        if (affectedRows === 0) {
          // Version mismatch - another user updated the event
          throw new TRPCError({
            code: "CONFLICT",
            message: `This event has been modified by another user. Please refresh and try again.`,
          });
        }
      } else {
        // No version provided - just update without version check (backward compatible)
        await calendarDb.updateEvent(input.id, dbUpdates as Parameters<typeof calendarDb.updateEvent>[1]);
      }

      // Log changes to history
      for (const [field, value] of Object.entries(input.updates)) {
        const oldValue = currentEvent[field as keyof typeof currentEvent];
        if (oldValue !== value) {
          await calendarDb.addHistoryEntry({
            eventId: input.id,
            changedBy: userId,
            changeType: "UPDATED",
            fieldChanged: field,
            previousValue: String(oldValue),
            newValue: String(value),
            changeReason: null,
          });
        }
      }

      // Regenerate instances if recurring and dates changed
      if (
        currentEvent.isRecurring &&
        (input.updates.startDate || input.updates.endDate)
      ) {
        await InstanceGenerationService.generateInstances(input.id, 90);
      }

      // Return new version for client to update its state
      const newVersion = input.version !== undefined ? input.version + 1 : ((currentEvent as any).version ?? 1);
      return { success: true, version: newVersion };
    }),

  // Delete event with cascade handling
  deleteEvent: publicProcedure
    .input(
      z.object({
        id: z.number(),
        deleteScope: z
          .enum(["THIS_INSTANCE", "THIS_AND_FUTURE", "ALL_INSTANCES"])
          .optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const userId = getAuthenticatedUserId(ctx);

      // Check permission
      const hasPermission = await PermissionService.hasPermission(userId, input.id, "DELETE");

      if (!hasPermission) {
        throw new Error("Permission denied");
      }

      // Soft delete event
      await calendarDb.softDeleteEvent(input.id);

      // Log to history
      await calendarDb.addHistoryEntry({
        eventId: input.id,
        changedBy: userId,
        changeType: "DELETED",
        fieldChanged: null,
        previousValue: null,
        newValue: null,
        changeReason: "Event deleted",
      });

      return { success: true };
    }),

  // Get events by entity (for linking)
  getEventsByEntity: publicProcedure
    .input(
      z.object({
        entityType: z.string(),
        entityId: z.number(),
      })
    )
    .query(async ({ input }) => {
      return await calendarDb.getEventsByEntity(
        input.entityType,
        input.entityId
      );
    }),

  // Get events assigned to user
  getMyEvents: protectedProcedure.query(async ({ ctx }) => {
    const userId = getAuthenticatedUserId(ctx);
    return await calendarDb.getEventsAssignedToUser(userId);
  }),

  // Get event history
  getEventHistory: publicProcedure
    .input(z.object({ eventId: z.number() }))
    .query(async ({ input }) => {
      return await calendarDb.getEventHistory(input.eventId);
    }),

  // Get event attachments
  getEventAttachments: publicProcedure
    .input(z.object({ eventId: z.number() }))
    .query(async ({ input }) => {
      return await calendarDb.getEventAttachments(input.eventId);
    }),

  // Get events by client ID
  getEventsByClient: publicProcedure
    .input(z.object({ clientId: z.number() }))
    .query(async ({ input }) => {
      return await calendarDb.getEventsByClient(input.clientId);
    }),
});
