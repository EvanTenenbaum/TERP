import { getDb } from "./db";
import {
  calendarEvents,
  calendarRecurrenceRules,
  calendarRecurrenceInstances,
  calendarEventParticipants,
  calendarReminders,
  calendarEventHistory,
  calendarEventAttachments,
  calendarViews,
  calendarEventPermissions,
  clientMeetingHistory,
  type InsertCalendarEvent,
  type InsertCalendarRecurrenceRule,
  type InsertCalendarRecurrenceInstance,
  type InsertCalendarEventParticipant,
  type InsertCalendarReminder,
  type InsertCalendarEventHistoryEntry,
  type InsertCalendarEventAttachment,
  type InsertCalendarView,
  type InsertCalendarEventPermission,
  type InsertClientMeetingHistoryEntry,
} from "../drizzle/schema";
import { eq, and, or, gte, lte, isNull, desc, type SQL } from "drizzle-orm";

/**
 * Calendar Database Access Layer
 * Handles all database operations for the Calendar & Scheduling Module
 * Version 2.0 - Post-Adversarial QA
 */

// ============================================================================
// CALENDAR EVENTS
// ============================================================================

/**
 * Get events by date range
 */
export async function getEventsByDateRange(
  startDate: string,
  endDate: string,
  _filters?: {
    modules?: string[];
    eventTypes?: string[];
    statuses?: string[];
    priorities?: string[];
    assignedTo?: number;
    includeAutoGenerated?: boolean;
  }
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const query = db
    .select()
    .from(calendarEvents)
    .where(
      and(
        gte(calendarEvents.startDate, new Date(startDate)),
        lte(calendarEvents.endDate, new Date(endDate)),
        isNull(calendarEvents.deletedAt)
      )
    );

  // Apply filters
  // Note: This is a simplified version. In production, you'd build the query dynamically
  
  return await query;
}

/**
 * Get event by ID
 */
export async function getEventById(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [event] = await db
    .select()
    .from(calendarEvents)
    .where(
      and(
        eq(calendarEvents.id, eventId),
        isNull(calendarEvents.deletedAt)
      )
    )
    .limit(1);

  return event;
}

/**
 * Create calendar event
 */
export async function createEvent(event: InsertCalendarEvent) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newEvent] = await db
    .insert(calendarEvents)
    .values(event)
    .$returningId();

  return newEvent;
}

/**
 * Update calendar event
 */
export async function updateEvent(eventId: number, updates: Partial<InsertCalendarEvent>) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarEvents)
    .set(updates)
    .where(eq(calendarEvents.id, eventId));

  return { success: true };
}

/**
 * Soft delete event
 */
export async function softDeleteEvent(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarEvents)
    .set({ deletedAt: new Date() })
    .where(eq(calendarEvents.id, eventId));

  return { success: true };
}

/**
 * Hard delete event
 */
export async function hardDeleteEvent(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarEvents)
    .where(eq(calendarEvents.id, eventId));

  return { success: true };
}

/**
 * Get events by entity
 */
export async function getEventsByEntity(entityType: string, entityId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEvents)
    .where(
      and(
        eq(calendarEvents.entityType, entityType),
        eq(calendarEvents.entityId, entityId),
        isNull(calendarEvents.deletedAt)
      )
    );
}

/**
 * Get events assigned to user
 */
export async function getEventsAssignedToUser(userId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEvents)
    .where(
      and(
        eq(calendarEvents.assignedTo, userId),
        isNull(calendarEvents.deletedAt)
      )
    );
}

// ============================================================================
// RECURRENCE RULES
// ============================================================================

/**
 * Get recurrence rule for event
 */
export async function getRecurrenceRule(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [rule] = await db
    .select()
    .from(calendarRecurrenceRules)
    .where(eq(calendarRecurrenceRules.eventId, eventId))
    .limit(1);

  return rule;
}

/**
 * Create recurrence rule
 */
export async function createRecurrenceRule(rule: InsertCalendarRecurrenceRule) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newRule] = await db
    .insert(calendarRecurrenceRules)
    .values(rule)
    .$returningId();

  return newRule;
}

/**
 * Update recurrence rule
 */
export async function updateRecurrenceRule(
  eventId: number,
  updates: Partial<InsertCalendarRecurrenceRule>
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarRecurrenceRules)
    .set(updates)
    .where(eq(calendarRecurrenceRules.eventId, eventId));

  return { success: true };
}

/**
 * Delete recurrence rule
 */
export async function deleteRecurrenceRule(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarRecurrenceRules)
    .where(eq(calendarRecurrenceRules.eventId, eventId));

  return { success: true };
}

// ============================================================================
// RECURRENCE INSTANCES
// ============================================================================

/**
 * Get instances for event
 */
export async function getInstancesByEvent(
  eventId: number,
  startDate?: string,
  endDate?: string
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const query = db
    .select()
    .from(calendarRecurrenceInstances)
    .where(eq(calendarRecurrenceInstances.parentEventId, eventId));

  // Note: Additional date filtering should be done in the initial query
  // For now, filter in memory if dates provided
  const results = await query;
  
  if (startDate && endDate) {
    const start = new Date(startDate);
    const end = new Date(endDate);
    return results.filter(r => {
      const instanceDate = new Date(r.instanceDate);
      return instanceDate >= start && instanceDate <= end;
    });
  }

  return results;
}

/**
 * Get instance by date
 */
export async function getInstanceByDate(eventId: number, instanceDate: string) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [instance] = await db
    .select()
    .from(calendarRecurrenceInstances)
    .where(
      and(
        eq(calendarRecurrenceInstances.parentEventId, eventId),
        eq(calendarRecurrenceInstances.instanceDate, new Date(instanceDate))
      )
    )
    .limit(1);

  return instance;
}

/**
 * Create instance
 */
export async function createInstance(instance: InsertCalendarRecurrenceInstance) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newInstance] = await db
    .insert(calendarRecurrenceInstances)
    .values(instance)
    .$returningId();

  return newInstance;
}

/**
 * Update instance
 */
export async function updateInstance(
  instanceId: number,
  updates: Partial<InsertCalendarRecurrenceInstance>
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarRecurrenceInstances)
    .set(updates)
    .where(eq(calendarRecurrenceInstances.id, instanceId));

  return { success: true };
}

/**
 * Delete instances for event
 */
export async function deleteInstancesByEvent(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarRecurrenceInstances)
    .where(eq(calendarRecurrenceInstances.parentEventId, eventId));

  return { success: true };
}

// ============================================================================
// EVENT PARTICIPANTS
// ============================================================================

/**
 * Get participants for event
 */
export async function getEventParticipants(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEventParticipants)
    .where(eq(calendarEventParticipants.eventId, eventId));
}

/**
 * Add participant to event
 */
export async function addParticipant(participant: InsertCalendarEventParticipant) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newParticipant] = await db
    .insert(calendarEventParticipants)
    .values(participant)
    .$returningId();

  return newParticipant;
}

/**
 * Update participant response
 */
export async function updateParticipantResponse(
  eventId: number,
  userId: number,
  responseStatus: "PENDING" | "ACCEPTED" | "DECLINED" | "TENTATIVE"
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarEventParticipants)
    .set({
      responseStatus,
      respondedAt: new Date(),
    })
    .where(
      and(
        eq(calendarEventParticipants.eventId, eventId),
        eq(calendarEventParticipants.userId, userId)
      )
    );

  return { success: true };
}

/**
 * Remove participant from event
 */
export async function removeParticipant(eventId: number, userId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarEventParticipants)
    .where(
      and(
        eq(calendarEventParticipants.eventId, eventId),
        eq(calendarEventParticipants.userId, userId)
      )
    );

  return { success: true };
}

// ============================================================================
// REMINDERS
// ============================================================================

/**
 * Get reminders for event
 */
export async function getEventReminders(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarReminders)
    .where(eq(calendarReminders.eventId, eventId));
}

/**
 * Get pending reminders
 */
export async function getPendingReminders(beforeTime: Date) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarReminders)
    .where(
      and(
        eq(calendarReminders.status, "PENDING"),
        lte(calendarReminders.reminderTime, beforeTime)
      )
    );
}

/**
 * Create reminder
 */
export async function createReminder(reminder: InsertCalendarReminder) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newReminder] = await db
    .insert(calendarReminders)
    .values(reminder)
    .$returningId();

  return newReminder;
}

/**
 * Update reminder status
 */
export async function updateReminderStatus(
  reminderId: number,
  status: "PENDING" | "SENT" | "FAILED" | "CANCELLED",
  failureReason?: string
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarReminders)
    .set({
      status,
      sentAt: status === "SENT" ? new Date() : undefined,
      failureReason,
    })
    .where(eq(calendarReminders.id, reminderId));

  return { success: true };
}

/**
 * Delete reminders for event
 */
export async function deleteEventReminders(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarReminders)
    .where(eq(calendarReminders.eventId, eventId));

  return { success: true };
}

// ============================================================================
// EVENT HISTORY
// ============================================================================

/**
 * Get event history
 */
export async function getEventHistory(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEventHistory)
    .where(eq(calendarEventHistory.eventId, eventId))
    .orderBy(desc(calendarEventHistory.changedAt));
}

/**
 * Add history entry
 */
export async function addHistoryEntry(entry: InsertCalendarEventHistoryEntry) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newEntry] = await db
    .insert(calendarEventHistory)
    .values(entry)
    .$returningId();

  return newEntry;
}

// ============================================================================
// EVENT ATTACHMENTS
// ============================================================================

/**
 * Get event attachments
 */
export async function getEventAttachments(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEventAttachments)
    .where(eq(calendarEventAttachments.eventId, eventId));
}

/**
 * Add attachment
 */
export async function addAttachment(attachment: InsertCalendarEventAttachment) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newAttachment] = await db
    .insert(calendarEventAttachments)
    .values(attachment)
    .$returningId();

  return newAttachment;
}

/**
 * Delete attachment
 */
export async function deleteAttachment(attachmentId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarEventAttachments)
    .where(eq(calendarEventAttachments.id, attachmentId));

  return { success: true };
}

// ============================================================================
// CALENDAR VIEWS
// ============================================================================

/**
 * Get user's calendar views
 */
export async function getUserViews(userId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarViews)
    .where(eq(calendarViews.userId, userId));
}

/**
 * Get user's default view
 */
export async function getUserDefaultView(userId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [view] = await db
    .select()
    .from(calendarViews)
    .where(
      and(
        eq(calendarViews.userId, userId),
        eq(calendarViews.isDefault, true)
      )
    )
    .limit(1);

  return view;
}

/**
 * Create calendar view
 */
export async function createView(view: InsertCalendarView) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newView] = await db
    .insert(calendarViews)
    .values(view)
    .$returningId();

  return newView;
}

/**
 * Update calendar view
 */
export async function updateView(viewId: number, updates: Partial<InsertCalendarView>) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(calendarViews)
    .set(updates)
    .where(eq(calendarViews.id, viewId));

  return { success: true };
}

/**
 * Delete calendar view
 */
export async function deleteView(viewId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarViews)
    .where(eq(calendarViews.id, viewId));

  return { success: true };
}

// ============================================================================
// EVENT PERMISSIONS
// ============================================================================

/**
 * Get event permissions
 */
export async function getEventPermissions(eventId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEventPermissions)
    .where(eq(calendarEventPermissions.eventId, eventId));
}

/**
 * Add permission
 */
export async function addPermission(permission: InsertCalendarEventPermission) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newPermission] = await db
    .insert(calendarEventPermissions)
    .values(permission)
    .$returningId();

  return newPermission;
}

/**
 * Delete permission
 */
export async function deletePermission(permissionId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .delete(calendarEventPermissions)
    .where(eq(calendarEventPermissions.id, permissionId));

  return { success: true };
}

// ============================================================================
// CLIENT MEETING HISTORY
// ============================================================================

/**
 * Get meeting history for client
 */
export async function getClientMeetingHistory(clientId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(clientMeetingHistory)
    .where(eq(clientMeetingHistory.clientId, clientId))
    .orderBy(desc(clientMeetingHistory.meetingDate));
}

/**
 * Add meeting history entry
 */
export async function addMeetingHistoryEntry(entry: InsertClientMeetingHistoryEntry) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const [newEntry] = await db
    .insert(clientMeetingHistory)
    .values(entry)
    .$returningId();

  return newEntry;
}

/**
 * Update meeting history entry
 */
export async function updateMeetingHistoryEntry(
  entryId: number,
  updates: Partial<InsertClientMeetingHistoryEntry>
) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  await db
    .update(clientMeetingHistory)
    .set(updates)
    .where(eq(clientMeetingHistory.id, entryId));

  return { success: true };
}

// ============================================================================
// v3.2: NEW QUERY FUNCTIONS
// ============================================================================

/**
 * Get events by client ID
 * v3.2: Uses explicit client_id foreign key for better performance
 */
export async function getEventsByClient(clientId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEvents)
    .where(
      and(
        eq(calendarEvents.clientId, clientId),
        isNull(calendarEvents.deletedAt)
      )
    )
    .orderBy(desc(calendarEvents.startDate));
}

/**
 * Get events by vendor ID
 * v3.2: Uses explicit vendor_id foreign key for better performance
 */
export async function getEventsByVendor(vendorId: number) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db
    .select()
    .from(calendarEvents)
    .where(
      and(
        eq(calendarEvents.vendorId, vendorId),
        isNull(calendarEvents.deletedAt)
      )
    )
    .orderBy(desc(calendarEvents.startDate));
}

/**
 * Check for conflicting events in a time range
 * v3.2: Fix #4 - Conflict detection for quick book
 * 
 * @param params - Time range and optional event to exclude
 * @returns Array of conflicting events
 */
export async function checkConflicts(params: {
  startDate: string;
  startTime: string;
  endDate: string;
  endTime: string;
  excludeEventId?: number;
}) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  const { startDate, endDate, excludeEventId } = params;
  
  // Convert string dates to Date objects
  const startDateObj = new Date(startDate);
  const endDateObj = new Date(endDate);

  // Build conditions
  const conditions: Array<SQL<unknown> | undefined> = [
    // Not cancelled
    or(
      eq(calendarEvents.status, "SCHEDULED"),
      eq(calendarEvents.status, "IN_PROGRESS"),
      eq(calendarEvents.status, "COMPLETED")
    ),
    // Not soft deleted
    isNull(calendarEvents.deletedAt),
    // Overlapping time range
    or(
      // New event starts during existing event
      and(
        lte(calendarEvents.startDate, startDateObj),
        gte(calendarEvents.endDate, startDateObj)
      ),
      // New event ends during existing event
      and(
        lte(calendarEvents.startDate, endDateObj),
        gte(calendarEvents.endDate, endDateObj)
      ),
      // New event completely contains existing event
      and(
        gte(calendarEvents.startDate, startDateObj),
        lte(calendarEvents.endDate, endDateObj)
      )
    ),
  ];

  // Exclude specific event if provided (for updates)
  if (excludeEventId) {
    conditions.push(eq(calendarEvents.id, excludeEventId));
  }

  return await db
    .select()
    .from(calendarEvents)
    .where(and(...conditions));
}

/**
 * Execute callback within a database transaction
 * v3.2: Fix #10 - Add transactions for multi-step operations
 * 
 * @param callback - Function to execute within transaction
 * @returns Result of callback
 */
export async function withTransaction<T>(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callback: (tx: any) => Promise<T>
): Promise<T> {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (!db) throw new Error("Database not available");

  return await db.transaction(async (tx) => {
    return await callback(tx);
  });
}
