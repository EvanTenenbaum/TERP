diff --git a/client/src/components/work-surface/DirectIntakeWorkSurface.tsx b/client/src/components/work-surface/DirectIntakeWorkSurface.tsx
index 6b691fed..5b76b223 100644
--- a/client/src/components/work-surface/DirectIntakeWorkSurface.tsx
+++ b/client/src/components/work-surface/DirectIntakeWorkSurface.tsx
@@ -40,6 +40,7 @@ import { Button } from "@/components/ui/button";
 import { Input } from "@/components/ui/input";
 import { Badge } from "@/components/ui/badge";
 import { Textarea } from "@/components/ui/textarea";
+import { Label } from "@/components/ui/label";
 import {
   Select,
   SelectContent,
@@ -200,6 +201,21 @@ const createEmptyRow = (defaults?: {
   status: "pending",
 });
 
+const normalizeRowForValidation = (row: IntakeGridRow): IntakeGridRow => {
+  const vendorName = row.vendorName.trim();
+  const brandName = row.brandName.trim() || vendorName;
+  const item = row.item.trim();
+  const site = row.site.trim();
+
+  return {
+    ...row,
+    vendorName,
+    brandName,
+    item,
+    site,
+  };
+};
+
 // ============================================================================
 // STATUS CELL RENDERER
 // ============================================================================
@@ -721,6 +737,18 @@ export function DirectIntakeWorkSurface() {
     [rows, selectedRowId]
   );
 
+  useEffect(() => {
+    if (rows.length === 0) {
+      setSelectedRowId(null);
+      return;
+    }
+    if (selectedRowId && rows.some(row => row.id === selectedRowId)) {
+      return;
+    }
+    const firstPending = rows.find(row => row.status === "pending");
+    setSelectedRowId(firstPending?.id ?? rows[0].id);
+  }, [rows, selectedRowId]);
+
   // Keyboard contract
   const { keyboardProps } = useWorkSurfaceKeyboard({
     gridMode: true, // Let AG Grid handle Tab navigation
@@ -858,50 +886,25 @@ export function DirectIntakeWorkSurface() {
   const columnDefs = useMemo<ColDef<IntakeGridRow>[]>(
     () => [
       {
-        // TER-217: Free-text + dropdown for rapid vendor entry
         headerName: "Vendor",
         field: "vendorName",
-        width: 160,
+        minWidth: 130,
+        flex: 1,
         editable: params => params.data?.status === "pending",
         cellEditor: "agTextCellEditor",
         cellEditorParams: {
           useFormatter: false,
         },
-        // Provide autocomplete suggestions via value setter
         tooltipValueGetter: () =>
           vendors.length > 0
             ? `Type to search ${vendors.length} vendors or enter new`
             : "Type vendor name",
       },
       {
-        headerName: "Brand/Farmer",
-        field: "brandName",
-        width: 140,
-        editable: params => params.data?.status === "pending",
-      },
-      {
-        // TER-223: Category defaults to Flower, subcategory is first-class
-        headerName: "Category",
-        field: "category",
-        width: 110,
-        editable: params => params.data?.status === "pending",
-        cellEditor: "agSelectCellEditor",
-        cellEditorParams: { values: CATEGORY_OPTIONS.map(c => c.value) },
-      },
-      {
-        // TER-223: Subcategory prioritized per user feedback
-        headerName: "Subcategory",
-        field: "subcategory",
-        width: 120,
-        editable: params => params.data?.status === "pending",
-        cellEditor: "agTextCellEditor",
-      },
-      {
-        // TER-217 + TER-221: Combined product/strain field with free-text
         headerName: "Product / Strain",
         field: "item",
-        flex: 1,
         minWidth: 180,
+        flex: 2,
         editable: params => params.data?.status === "pending",
         cellEditor: "agTextCellEditor",
         cellEditorParams: {
@@ -915,7 +918,7 @@ export function DirectIntakeWorkSurface() {
       {
         headerName: "Qty",
         field: "qty",
-        width: 100,
+        width: 90,
         editable: params => params.data?.status === "pending",
         valueParser: params => {
           const val = Number(params.newValue);
@@ -925,7 +928,7 @@ export function DirectIntakeWorkSurface() {
       {
         headerName: "COGS",
         field: "cogs",
-        width: 120,
+        width: 100,
         editable: params => params.data?.status === "pending",
         valueFormatter: params => `$${(params.value ?? 0).toFixed(2)}`,
         valueParser: params => {
@@ -933,27 +936,19 @@ export function DirectIntakeWorkSurface() {
           return Number.isFinite(val) && val >= 0 ? val : params.oldValue;
         },
       },
-      {
-        headerName: "Payment",
-        field: "paymentTerms",
-        width: 120,
-        editable: params => params.data?.status === "pending",
-        cellEditor: "agSelectCellEditor",
-        cellEditorParams: { values: PAYMENT_TERMS_OPTIONS.map(p => p.value) },
-      },
       {
         headerName: "Location",
         field: "site",
-        width: 130,
+        minWidth: 120,
+        flex: 1,
         editable: params => params.data?.status === "pending",
         cellEditor: "agSelectCellEditor",
         cellEditorParams: { values: locations.map(l => l.site) },
       },
       {
-        // TER-224: Notes indicator for traceability
         headerName: "Notes",
         field: "notes",
-        width: 60,
+        width: 70,
         editable: false,
         sortable: false,
         filter: false,
@@ -980,9 +975,9 @@ export function DirectIntakeWorkSurface() {
         editable: false,
       },
       {
-        headerName: "",
+        headerName: "Edit",
         colId: "actions",
-        width: 50,
+        width: 64,
         cellRenderer: (params: ICellRendererParams<IntakeGridRow>) => (
           <Button
             variant="ghost"
@@ -1017,6 +1012,9 @@ export function DirectIntakeWorkSurface() {
   // Event handlers
   const handleGridReady = useCallback((event: GridReadyEvent) => {
     gridApiRef.current = event.api;
+    requestAnimationFrame(() => {
+      event.api.sizeColumnsToFit();
+    });
   }, []);
 
   const handleCellValueChanged = useCallback(
@@ -1025,61 +1023,74 @@ export function DirectIntakeWorkSurface() {
 
       setSaving(); // Mark as saving when changes occur
 
-      // Update vendor ID when vendor name changes
+      const nextRow: IntakeGridRow = {
+        ...event.data,
+      };
+
+      // Normalize vendor linkage (and auto-fill brand) when vendor name changes.
       if (event.colDef.field === "vendorName") {
-        const vendor = vendors.find(v => v.name === event.newValue);
+        const nextVendorName =
+          typeof event.newValue === "string" ? event.newValue.trim() : "";
+        nextRow.vendorName = nextVendorName;
+        if (!nextRow.brandName?.trim() && nextVendorName) {
+          nextRow.brandName = nextVendorName;
+        }
+
+        const vendor = vendors.find(v => v.name === nextVendorName);
         if (vendor) {
-          event.node.setDataValue("vendorId", vendor.id);
-          if (!event.data.brandName) {
-            event.node.setDataValue("brandName", vendor.name);
+          nextRow.vendorId = vendor.id;
+          if (!nextRow.brandName?.trim()) {
+            nextRow.brandName = vendor.name;
           }
         } else {
-          // Clear stale vendorId when text no longer matches an existing vendor
-          event.node.setDataValue("vendorId", null);
+          nextRow.vendorId = null;
         }
       }
 
-      // Update location ID and site when location name changes
+      // Normalize location linkage when site changes.
       if (event.colDef.field === "site") {
-        const location = locations.find(l => l.site === event.newValue);
+        const nextSite =
+          typeof event.newValue === "string" ? event.newValue.trim() : "";
+        nextRow.site = nextSite;
+        const location = locations.find(l => l.site === nextSite);
         if (location) {
-          event.node.setDataValue("locationId", location.id);
+          nextRow.locationId = location.id;
+          nextRow.locationName = location.site;
+        } else {
+          nextRow.locationId = null;
+          nextRow.locationName = "";
         }
       }
 
-      // Update product selection when item/product changes
+      // Normalize product linkage when item text changes.
       if (event.colDef.field === "item") {
-        const product = products.find(p => p.name === event.newValue);
+        const nextItem =
+          typeof event.newValue === "string" ? event.newValue.trim() : "";
+        nextRow.item = nextItem;
+        const product = products.find(p => p.name === nextItem);
         if (product) {
-          event.node.setDataValue("productId", product.id);
-          event.node.setDataValue("strainId", product.strainId ?? null);
-          event.node.setDataValue("category", product.category);
+          nextRow.productId = product.id;
+          nextRow.strainId = product.strainId ?? null;
+          nextRow.category = product.category as IntakeRowData["category"];
         } else {
-          // Clear stale IDs when product text no longer matches an existing product
-          event.node.setDataValue("productId", null);
-          event.node.setDataValue("strainId", null);
+          nextRow.productId = null;
+          nextRow.strainId = null;
         }
       }
 
       // Reset error status when editing after a validation failure
-      if (event.data.status === "error") {
-        event.node.setDataValue("status", "pending");
-        event.node.setDataValue("errorMessage", undefined);
+      if (nextRow.status === "error") {
+        nextRow.status = "pending";
+        nextRow.errorMessage = undefined;
       }
 
       // Update rows state
       setRows(prevRows =>
         prevRows.map(row =>
-          row.id === event.data?.id
+          row.id === nextRow.id
             ? {
                 ...row,
-                ...event.data,
-                status:
-                  event.data.status === "error" ? "pending" : event.data.status,
-                errorMessage:
-                  event.data.status === "error"
-                    ? undefined
-                    : event.data.errorMessage,
+                ...nextRow,
               }
             : row
         )
@@ -1183,8 +1194,13 @@ export function DirectIntakeWorkSurface() {
 
   const handleSubmitRow = useCallback(
     async (row: IntakeGridRow) => {
+      const normalizedRow = normalizeRowForValidation(row);
+      setRows(prev =>
+        prev.map(r => (r.id === row.id ? { ...r, ...normalizedRow } : r))
+      );
+
       // Validate
-      const result = intakeRowSchema.safeParse(row);
+      const result = intakeRowSchema.safeParse(normalizedRow);
       if (!result.success) {
         const firstError = result.error.issues[0];
         setRows(prev =>
@@ -1220,18 +1236,20 @@ export function DirectIntakeWorkSurface() {
 
         setSaving("Submitting intake...");
         await intakeMutation.mutateAsync({
-          vendorName: row.vendorName,
-          brandName: row.brandName,
-          productName: row.item,
-          category: row.category,
-          subcategory: row.subcategory || undefined,
-          strainId: row.strainId,
-          quantity: row.qty,
+          vendorName: normalizedRow.vendorName,
+          brandName: normalizedRow.brandName,
+          productName: normalizedRow.item,
+          category: normalizedRow.category,
+          subcategory: normalizedRow.subcategory || undefined,
+          strainId: normalizedRow.strainId,
+          quantity: normalizedRow.qty,
           cogsMode: "FIXED" as const,
-          unitCogs: row.cogs.toFixed(2),
-          paymentTerms: row.paymentTerms,
-          location: { site: row.site },
-          metadata: row.notes ? { notes: row.notes } : undefined,
+          unitCogs: normalizedRow.cogs.toFixed(2),
+          paymentTerms: normalizedRow.paymentTerms,
+          location: { site: normalizedRow.site },
+          metadata: normalizedRow.notes
+            ? { notes: normalizedRow.notes }
+            : undefined,
           mediaUrls:
             uploadedMediaUrls.length > 0 ? uploadedMediaUrls : undefined,
         });
@@ -1289,9 +1307,22 @@ export function DirectIntakeWorkSurface() {
   );
 
   const handleSubmitAll = useCallback(async () => {
-    const validationResults = rows
+    const normalizedPendingRows = rows
       .filter(row => row.status === "pending")
-      .map(row => ({ row, result: intakeRowSchema.safeParse(row) }));
+      .map(normalizeRowForValidation);
+
+    setRows(prev =>
+      prev.map(row => {
+        if (row.status !== "pending") return row;
+        const normalized = normalizedPendingRows.find(r => r.id === row.id);
+        return normalized ? { ...row, ...normalized } : row;
+      })
+    );
+
+    const validationResults = normalizedPendingRows.map(row => ({
+      row,
+      result: intakeRowSchema.safeParse(row),
+    }));
 
     const invalidRows = validationResults.filter(
       ({ result }) => !result.success
@@ -1436,12 +1467,30 @@ export function DirectIntakeWorkSurface() {
       setRows(prev =>
         prev.map(r =>
           r.id === selectedRowId
-            ? {
-                ...r,
-                ...updates,
-                status: r.status === "error" ? "pending" : r.status,
-                errorMessage: r.status === "error" ? undefined : r.errorMessage,
-              }
+            ? (() => {
+                const nextVendorName =
+                  typeof updates.vendorName === "string"
+                    ? updates.vendorName.trim()
+                    : undefined;
+                const shouldBackfillBrand =
+                  typeof updates.brandName === "undefined" &&
+                  !!nextVendorName &&
+                  !r.brandName.trim();
+
+                return {
+                  ...r,
+                  ...updates,
+                  ...(typeof nextVendorName === "string"
+                    ? { vendorName: nextVendorName }
+                    : {}),
+                  ...(shouldBackfillBrand
+                    ? { brandName: nextVendorName }
+                    : {}),
+                  status: r.status === "error" ? "pending" : r.status,
+                  errorMessage:
+                    r.status === "error" ? undefined : r.errorMessage,
+                };
+              })()
             : r
         )
       );
@@ -1450,6 +1499,19 @@ export function DirectIntakeWorkSurface() {
     [selectedRowId, setSaving, setSaved]
   );
 
+  useEffect(() => {
+    const fitGrid = () => {
+      if (!gridApiRef.current) return;
+      gridApiRef.current.sizeColumnsToFit();
+    };
+    const timer = window.setTimeout(fitGrid, 0);
+    window.addEventListener("resize", fitGrid);
+    return () => {
+      window.clearTimeout(timer);
+      window.removeEventListener("resize", fitGrid);
+    };
+  }, [rows.length, inspector.isOpen]);
+
   // Summary calculation
   const summary = useMemo<IntakeSummary>(() => {
     const pendingRows = rows.filter(r => r.status === "pending");
@@ -1460,59 +1522,208 @@ export function DirectIntakeWorkSurface() {
     };
   }, [rows]);
 
+  const pendingCount = rows.filter(r => r.status === "pending").length;
+  const submittedCount = rows.filter(r => r.status === "submitted").length;
+  const errorCount = rows.filter(r => r.status === "error").length;
+  const selectedRowEditable = !!selectedRow && selectedRow.status !== "submitted";
+
   // Render
   return (
-    <div
+    <section
       {...keyboardProps}
-      className="h-full min-h-[calc(100vh-8rem)] flex flex-col"
+      className="linear-workspace-shell h-full min-h-[calc(100vh-8rem)] flex flex-col overflow-hidden"
     >
-      {/* Header */}
-      <div className="flex items-center justify-between px-6 py-4 border-b bg-background">
-        <div>
-          <h2 className="text-2xl font-bold tracking-tight flex items-center gap-3">
-            <Package className="h-6 w-6" />
-            Direct Intake
-          </h2>
-          <p className="text-sm text-muted-foreground mt-1">
-            Add new inventory batches with full validation
-          </p>
+      <header className="linear-workspace-header">
+        <div className="linear-workspace-title-wrap">
+          <p className="linear-workspace-eyebrow">Inventory Intake</p>
+          <div>
+            <h2 className="linear-workspace-title flex items-center gap-2">
+              <Package className="h-5 w-5" />
+              Direct Intake
+            </h2>
+            <p className="linear-workspace-description">
+              Keep key fields front and center, then use row details for everything else.
+            </p>
+          </div>
         </div>
-        <div className="flex items-center gap-4">
-          {/* Save State Indicator */}
+        <div className="flex items-center gap-3">
           {SaveStateIndicator}
+          <Button
+            variant="outline"
+            size="sm"
+            onClick={() => inspector.open()}
+            disabled={!selectedRow}
+          >
+            Edit Selected Details
+          </Button>
+        </div>
+      </header>
 
-          {/* Summary Stats */}
-          <div className="text-sm text-muted-foreground flex gap-4">
-            <span>
-              Items:{" "}
-              <span className="font-semibold text-foreground">
-                {summary.totalItems}
-              </span>
-            </span>
-            <span>
-              Qty:{" "}
-              <span className="font-semibold text-foreground">
-                {summary.totalQty}
-              </span>
-            </span>
-            <span>
-              Value:{" "}
-              <span className="font-semibold text-foreground">
-                ${summary.totalValue.toFixed(2)}
-              </span>
-            </span>
+      <div className="linear-workspace-meta">
+        <div className="linear-workspace-meta-item">
+          <span className="linear-workspace-meta-label">Pending</span>
+          <span className="linear-workspace-meta-value">{pendingCount}</span>
+        </div>
+        <div className="linear-workspace-meta-item">
+          <span className="linear-workspace-meta-label">Submitted</span>
+          <span className="linear-workspace-meta-value">{submittedCount}</span>
+        </div>
+        <div className="linear-workspace-meta-item">
+          <span className="linear-workspace-meta-label">Errors</span>
+          <span className={cn("linear-workspace-meta-value", errorCount > 0 && "text-red-600")}>
+            {errorCount}
+          </span>
+        </div>
+        <div className="linear-workspace-meta-item">
+          <span className="linear-workspace-meta-label">Qty</span>
+          <span className="linear-workspace-meta-value">{summary.totalQty}</span>
+        </div>
+        <div className="linear-workspace-meta-item">
+          <span className="linear-workspace-meta-label">Value</span>
+          <span className="linear-workspace-meta-value">${summary.totalValue.toFixed(2)}</span>
+        </div>
+      </div>
+
+      <div className="border-b border-border/70 bg-background px-3 py-3 md:px-4">
+        <div className="grid gap-2 md:grid-cols-5">
+          <div className="space-y-1">
+            <Label className="text-xs text-muted-foreground">Vendor</Label>
+            <Select
+              value={selectedRow?.vendorName ?? ""}
+              onValueChange={value => {
+                if (!selectedRow) return;
+                if (value === "__CREATE_NEW__") {
+                  const name = window.prompt("Enter new vendor name:");
+                  if (name?.trim()) {
+                    handleUpdateSelectedRow({
+                      vendorName: name.trim(),
+                      vendorId: null,
+                      brandName: selectedRow.brandName || name.trim(),
+                    });
+                  }
+                  return;
+                }
+                const vendor = vendors.find(v => v.name === value);
+                handleUpdateSelectedRow({
+                  vendorName: value,
+                  vendorId: vendor?.id ?? null,
+                  brandName: selectedRow.brandName || value,
+                });
+              }}
+              disabled={!selectedRowEditable}
+            >
+              <SelectTrigger className="h-9">
+                <SelectValue placeholder="Select vendor" />
+              </SelectTrigger>
+              <SelectContent>
+                {vendors.map(v => (
+                  <SelectItem key={v.id} value={v.name}>
+                    {v.name}
+                  </SelectItem>
+                ))}
+                <SelectItem value="__CREATE_NEW__" className="text-primary font-medium">
+                  + Create New Vendor
+                </SelectItem>
+              </SelectContent>
+            </Select>
+          </div>
+          <div className="space-y-1">
+            <Label className="text-xs text-muted-foreground">Product / Strain</Label>
+            <Select
+              value={selectedRow?.item ?? ""}
+              onValueChange={value => {
+                if (!selectedRow) return;
+                const product = products.find(p => p.name === value);
+                handleUpdateSelectedRow({
+                  item: value,
+                  productId: product?.id ?? null,
+                  strainId: product?.strainId ?? null,
+                  category: (product?.category as IntakeRowData["category"]) ?? selectedRow.category,
+                });
+              }}
+              disabled={!selectedRowEditable}
+            >
+              <SelectTrigger className="h-9">
+                <SelectValue placeholder="Select product" />
+              </SelectTrigger>
+              <SelectContent>
+                {products.map(product => (
+                  <SelectItem key={product.id} value={product.name}>
+                    {product.name}
+                  </SelectItem>
+                ))}
+              </SelectContent>
+            </Select>
+          </div>
+          <div className="space-y-1">
+            <Label className="text-xs text-muted-foreground">Qty</Label>
+            <Input
+              type="number"
+              min="0"
+              step="0.01"
+              value={selectedRow?.qty ?? ""}
+              onChange={e => {
+                const val = Number(e.target.value);
+                handleUpdateSelectedRow({ qty: Number.isFinite(val) ? val : 0 });
+              }}
+              disabled={!selectedRowEditable}
+              className="h-9"
+            />
+          </div>
+          <div className="space-y-1">
+            <Label className="text-xs text-muted-foreground">COGS</Label>
+            <Input
+              type="number"
+              min="0"
+              step="0.01"
+              value={selectedRow?.cogs ?? ""}
+              onChange={e => {
+                const val = Number(e.target.value);
+                handleUpdateSelectedRow({ cogs: Number.isFinite(val) ? val : 0 });
+              }}
+              disabled={!selectedRowEditable}
+              className="h-9"
+            />
+          </div>
+          <div className="space-y-1">
+            <Label className="text-xs text-muted-foreground">Location</Label>
+            <Select
+              value={selectedRow?.site ?? ""}
+              onValueChange={value => {
+                if (!selectedRow) return;
+                const location = locations.find(l => l.site === value);
+                handleUpdateSelectedRow({
+                  site: value,
+                  locationId: location?.id ?? null,
+                  locationName: value,
+                });
+              }}
+              disabled={!selectedRowEditable}
+            >
+              <SelectTrigger className="h-9">
+                <SelectValue placeholder="Select location" />
+              </SelectTrigger>
+              <SelectContent>
+                {locations.map(l => (
+                  <SelectItem key={l.id} value={l.site}>
+                    {l.site}
+                  </SelectItem>
+                ))}
+              </SelectContent>
+            </Select>
           </div>
         </div>
+        {selectedRow?.status === "error" && selectedRow.errorMessage && (
+          <p className="mt-2 text-xs font-medium text-red-600">{selectedRow.errorMessage}</p>
+        )}
       </div>
 
-      {/* Toolbar */}
-      <div className="flex items-center justify-between px-6 py-3 border-b bg-muted/30">
-        <div className="flex gap-2">
+      <div className="linear-workspace-tab-row !min-h-0">
+        <div className="linear-workspace-command-strip !ml-0">
           <Button variant="outline" size="sm" onClick={handleAddRow}>
             <Plus className="mr-1 h-4 w-4" />
             Add Row
           </Button>
-          {/* TER-218: Quick add multiple rows */}
           <Button
             variant="outline"
             size="sm"
@@ -1526,6 +1737,12 @@ export function DirectIntakeWorkSurface() {
             <Plus className="mr-1 h-4 w-4" />
             +5 Rows
           </Button>
+          {selectedRow?.status === "pending" && (
+            <Button size="sm" variant="outline" onClick={() => handleSubmitRow(selectedRow)}>
+              <Send className="mr-1 h-4 w-4" />
+              Submit Selected
+            </Button>
+          )}
           {selectedRowId && selectedRow?.status === "pending" && (
             <Button
               variant="outline"
@@ -1536,38 +1753,29 @@ export function DirectIntakeWorkSurface() {
               Remove
             </Button>
           )}
+          <Button
+            size="sm"
+            onClick={handleSubmitAll}
+            disabled={isSubmitting || pendingCount === 0}
+          >
+            {isSubmitting ? (
+              <>
+                <Loader2 className="mr-1 h-4 w-4 animate-spin" />
+                Submitting...
+              </>
+            ) : (
+              <>
+                <Send className="mr-1 h-4 w-4" />
+                Submit All Pending
+              </>
+            )}
+          </Button>
         </div>
-        <Button
-          size="sm"
-          onClick={handleSubmitAll}
-          disabled={
-            isSubmitting ||
-            rows.filter(r => r.status === "pending").length === 0
-          }
-        >
-          {isSubmitting ? (
-            <>
-              <Loader2 className="mr-1 h-4 w-4 animate-spin" />
-              Submitting...
-            </>
-          ) : (
-            <>
-              <Send className="mr-1 h-4 w-4" />
-              Submit All
-            </>
-          )}
-        </Button>
       </div>
 
-      {/* Main Content */}
       <div className="flex-1 flex overflow-hidden min-h-0">
         {/* Grid Area */}
-        <div
-          className={cn(
-            "flex-1 transition-all duration-200 min-h-0",
-            inspector.isOpen && "mr-96"
-          )}
-        >
+        <div className="flex-1 min-h-0 overflow-x-hidden">
           {isLoadingData ? (
             <div className="flex items-center justify-center h-full">
               <div className="text-center">
@@ -1664,7 +1872,7 @@ export function DirectIntakeWorkSurface() {
           )}
         </InspectorPanel>
       </div>
-    </div>
+    </section>
   );
 }
 
diff --git a/tests-e2e/golden-flows/gf-001-direct-intake.spec.ts b/tests-e2e/golden-flows/gf-001-direct-intake.spec.ts
index 877b7545..a9d25775 100644
--- a/tests-e2e/golden-flows/gf-001-direct-intake.spec.ts
+++ b/tests-e2e/golden-flows/gf-001-direct-intake.spec.ts
@@ -7,68 +7,143 @@
 import { expect, test, type Page } from "@playwright/test";
 import { loginAsInventoryManager } from "../fixtures/auth";
 import {
-  cleanupBatchesByBrandName,
+  closeInventoryBatches,
+  fetchInventoryByQuery,
   fillAgGridTextCell,
   readAgGridCellText,
-  selectAgGridFirstOption,
+  trpcQuery,
   waitForToast,
 } from "../utils/golden-flow-helpers";
 
-const createBrandName = (): string => `E2E Brand ${new Date().toISOString()}`;
+const createItemName = (): string => `E2E Item ${new Date().toISOString()}`;
 
-test.describe("Golden Flow: GF-001 Direct Intake", (): void => {
-  let brandName: string | null = null;
+const setSelectedRowLocation = async (
+  page: Page,
+  locationName: string
+): Promise<void> => {
+  const locationField = page
+    .getByText("Location", { exact: true })
+    .first()
+    .locator("xpath=..")
+    .getByRole("combobox")
+    .first();
 
-  const _gotoDirectIntake = async (page: Page): Promise<void> => {
-    await page.goto("/intake");
-    await page.waitForLoadState("networkidle");
+  await locationField.click();
+  await page.getByRole("option", { name: locationName }).first().click();
+};
 
-    const addRowOnCanonicalRoute = await page
-      .getByRole("button", { name: "Add Row" })
+const navigateToDirectIntake = async (page: Page): Promise<void> => {
+  await page.goto("/direct-intake");
+  await page.waitForLoadState("networkidle");
+  if (
+    await page
+      .getByText("404")
       .isVisible()
-      .catch(() => false);
+      .catch(() => false)
+  ) {
+    await page.goto("/inventory/intake");
+  }
+  await page.waitForLoadState("networkidle");
+  if (
+    await page
+      .getByText("404")
+      .isVisible()
+      .catch(() => false)
+  ) {
+    await page.goto("/inventory/intake");
+  }
+  await page.waitForLoadState("networkidle");
+};
+
+const findFirstVendorName = async (page: Page): Promise<string> => {
+  const result = await trpcQuery<{
+    items?: Array<{ name?: string }>;
+    data?: Array<{ name?: string }>;
+  }>(page, "clients.list", {
+    clientTypes: ["seller"],
+    limit: 25,
+  });
+
+  const candidates = Array.isArray(result.items)
+    ? result.items
+    : Array.isArray(result.data)
+      ? result.data
+      : [];
+
+  const vendorName = candidates.find(
+    candidate =>
+      typeof candidate.name === "string" && candidate.name.trim().length > 0
+  )?.name;
 
-    if (addRowOnCanonicalRoute) return;
+  if (!vendorName) {
+    throw new Error(
+      "No seller clients found for GF-001. Seed data must include at least one vendor."
+    );
+  }
 
-    await page.goto("/direct-intake");
-    await page.waitForLoadState("networkidle");
-  };
+  return vendorName;
+};
+
+const cleanupBatchesByItemName = async (
+  page: Page,
+  itemName: string
+): Promise<void> => {
+  const isCleanupSkippable = (message: string): boolean =>
+    message.includes("status 401") ||
+    message.includes("status 403") ||
+    message.includes("status 429") ||
+    message.includes("status 500");
+
+  let list: Awaited<ReturnType<typeof fetchInventoryByQuery>>;
+  try {
+    list = await fetchInventoryByQuery(page, itemName);
+  } catch (error) {
+    const message = error instanceof Error ? error.message : String(error);
+    if (isCleanupSkippable(message)) return;
+    throw error;
+  }
+
+  const needle = itemName.toLowerCase();
+  const batchIds = list.items
+    .filter(item => {
+      const productName = (
+        item.product?.nameCanonical ??
+        item.product?.name ??
+        ""
+      ).toLowerCase();
+      return productName.includes(needle);
+    })
+    .map(item => item.batch.id);
+
+  try {
+    await closeInventoryBatches(page, batchIds);
+  } catch (error) {
+    const message = error instanceof Error ? error.message : String(error);
+    if (!isCleanupSkippable(message)) throw error;
+  }
+};
+
+test.describe("Golden Flow: GF-001 Direct Intake", (): void => {
+  let itemName: string | null = null;
 
   test.beforeEach(async ({ page }): Promise<void> => {
     await loginAsInventoryManager(page);
   });
 
   test.afterEach(async ({ page }): Promise<void> => {
-    if (!brandName) return;
-    await cleanupBatchesByBrandName(page, brandName);
-    brandName = null;
+    if (!itemName) return;
+    await cleanupBatchesByItemName(page, itemName);
+    itemName = null;
   });
 
   test("should submit intake row and create a batch", async ({
     page,
   }): Promise<void> => {
-    brandName = createBrandName();
-
-    await page.goto("/direct-intake");
-    await page.waitForLoadState("networkidle");
-    if (
-      await page
-        .getByText("404")
-        .isVisible()
-        .catch(() => false)
-    ) {
-      await page.goto("/inventory/intake");
-    }
-    await page.waitForLoadState("networkidle");
-    if (
-      await page
-        .getByText("404")
-        .isVisible()
-        .catch(() => false)
-    ) {
-      await page.goto("/inventory/intake");
-    }
-    await page.waitForLoadState("networkidle");
+    test.setTimeout(120_000);
+    itemName = createItemName();
+    const vendorName = await findFirstVendorName(page);
+
+    await navigateToDirectIntake(page);
 
     const addRowButton = page.getByRole("button", { name: "Add Row" });
     const hasIntakeSurface = await addRowButton.isVisible().catch(() => false);
@@ -80,9 +155,6 @@ test.describe("Golden Flow: GF-001 Direct Intake", (): void => {
       return;
     }
     const rows = page.locator(".ag-center-cols-container .ag-row");
-
-    // Wait for AG Grid to finish rendering initial rows before snapshotting count.
-    await expect(rows.first()).toBeVisible({ timeout: 10_000 });
     const initialRowCount = await rows.count();
 
     await addRowButton.click();
@@ -90,26 +162,263 @@ test.describe("Golden Flow: GF-001 Direct Intake", (): void => {
     // Wait for at least one new row to appear.
     await expect(rows).toHaveCount(initialRowCount + 1, { timeout: 10_000 });
 
-    // Derive the new row's AG Grid row-index from the DOM instead of assuming
-    // it equals initialRowCount.
-    const lastRow = rows.last();
-    const rowIndexAttr = await lastRow.getAttribute("row-index");
-    const rowIndex =
-      rowIndexAttr !== null ? parseInt(rowIndexAttr, 10) : initialRowCount;
-
-    await selectAgGridFirstOption(page, rowIndex, "vendorName");
-    await fillAgGridTextCell(page, rowIndex, "brandName", brandName);
-    await selectAgGridFirstOption(page, rowIndex, "category");
-    await selectAgGridFirstOption(page, rowIndex, "item");
+    const rowIndex = initialRowCount;
+    await expect(
+      page.locator(`.ag-center-cols-container .ag-row[row-index="${rowIndex}"]`)
+    ).toBeVisible({ timeout: 10_000 });
+
+    await fillAgGridTextCell(page, rowIndex, "vendorName", vendorName);
+    await fillAgGridTextCell(page, rowIndex, "item", itemName);
     await fillAgGridTextCell(page, rowIndex, "qty", "10");
     await fillAgGridTextCell(page, rowIndex, "cogs", "125");
-    await selectAgGridFirstOption(page, rowIndex, "site");
+    await setSelectedRowLocation(page, "Main Warehouse");
+    await expect
+      .poll(async () => await readAgGridCellText(page, rowIndex, "site"), {
+        timeout: 10_000,
+      })
+      .toMatch(/\S+/);
+
+    await page.getByRole("button", { name: "Edit Selected Details" }).click();
+    const brandName = `${itemName} Brand`;
+    const brandInput = page.getByPlaceholder("Enter brand or farmer name");
+    await expect(brandInput).toBeVisible({ timeout: 10_000 });
+    await brandInput.fill(brandName);
+
+    await page.getByRole("button", { name: /Submit Selected/i }).click();
+
+    const toastSeen = await waitForToast(page, "Successfully submitted")
+      .then(() => true)
+      .catch(() => false);
+
+    // Status is the source-of-truth assertion; toast is best-effort UI evidence.
+    await expect
+      .poll(
+        async () =>
+          (await readAgGridCellText(page, rowIndex, "status")).toLowerCase(),
+        { timeout: 60_000 }
+      )
+      .toContain("submitted");
+
+    if (!toastSeen) {
+      test.info().annotations.push({
+        type: "observation",
+        description:
+          "Submit toast was not observed within timeout, but status updated to Submitted.",
+      });
+    }
+  });
+
+  test("should submit a valid row from Submit All Pending without request-id errors", async ({
+    page,
+  }): Promise<void> => {
+    test.setTimeout(120_000);
+    itemName = createItemName();
+    const vendorName = await findFirstVendorName(page);
+
+    await navigateToDirectIntake(page);
+
+    const addRowButton = page.getByRole("button", { name: "Add Row" });
+    const hasIntakeSurface = await addRowButton.isVisible().catch(() => false);
+    if (!hasIntakeSurface) {
+      test.skip(
+        true,
+        "Direct intake UI is not available in this deployment/role context"
+      );
+      return;
+    }
+
+    const rowIndex = 0;
+    await fillAgGridTextCell(page, rowIndex, "vendorName", vendorName);
+    await fillAgGridTextCell(page, rowIndex, "item", itemName);
+    await fillAgGridTextCell(page, rowIndex, "qty", "100");
+    await fillAgGridTextCell(page, rowIndex, "cogs", "1250");
+    await setSelectedRowLocation(page, "Main Warehouse");
+
+    await page.getByRole("button", { name: "Edit Selected Details" }).click();
+    const brandInput = page.getByPlaceholder("Enter brand or farmer name");
+    await expect(brandInput).toBeVisible({ timeout: 10_000 });
+    await brandInput.fill(`${itemName} Brand`);
+    await page.keyboard.press("Escape");
+    await expect(
+      page.getByRole("complementary", { name: "Edit Row" })
+    ).toBeHidden({ timeout: 10_000 });
+
+    const intakeStatuses: number[] = [];
+    page.on("response", response => {
+      if (response.url().includes("/api/trpc/inventory.intake")) {
+        intakeStatuses.push(response.status());
+      }
+    });
+
+    await page.getByRole("button", { name: "Submit All Pending" }).click();
+
+    await expect
+      .poll(
+        async () =>
+          (await readAgGridCellText(page, rowIndex, "status")).toLowerCase(),
+        { timeout: 60_000 }
+      )
+      .toContain("submitted");
+
+    await expect
+      .poll(async () => intakeStatuses.length, { timeout: 30_000 })
+      .toBeGreaterThan(0);
+    expect(intakeStatuses.some(status => status >= 500)).toBeFalsy();
+
+    const requestIdError = page
+      .locator("text=An unexpected error occurred")
+      .or(page.locator("text=Request ID: REQ-"));
+    await expect(requestIdError).toHaveCount(0);
+  });
+
+  test("should not throw internal request-id errors when submit-all includes mixed pending rows", async ({
+    page,
+  }): Promise<void> => {
+    test.setTimeout(120_000);
+    itemName = createItemName();
+    const vendorName = await findFirstVendorName(page);
+
+    await navigateToDirectIntake(page);
+
+    const addRowButton = page.getByRole("button", { name: "Add Row" });
+    const addFiveRowsButton = page.getByRole("button", { name: "+5 Rows" });
+    const hasIntakeSurface = await addRowButton.isVisible().catch(() => false);
+    if (!hasIntakeSurface) {
+      test.skip(
+        true,
+        "Direct intake UI is not available in this deployment/role context"
+      );
+      return;
+    }
+
+    const rows = page.locator(".ag-center-cols-container .ag-row");
+    const initialRowCount = await rows.count();
+    await addFiveRowsButton.click();
+    await expect(rows).toHaveCount(initialRowCount + 5, { timeout: 10_000 });
+
+    const rowIndex = initialRowCount;
+    await fillAgGridTextCell(page, rowIndex, "vendorName", vendorName);
+    await fillAgGridTextCell(page, rowIndex, "item", itemName);
+    await fillAgGridTextCell(page, rowIndex, "qty", "100");
+    await fillAgGridTextCell(page, rowIndex, "cogs", "1250");
+    await setSelectedRowLocation(page, "Main Warehouse");
+
+    await page.getByRole("button", { name: "Edit Selected Details" }).click();
+    const brandInput = page.getByPlaceholder("Enter brand or farmer name");
+    await expect(brandInput).toBeVisible({ timeout: 10_000 });
+    await brandInput.fill(`${itemName} Brand`);
+    await page.keyboard.press("Escape");
+    await expect(
+      page.getByRole("complementary", { name: "Edit Row" })
+    ).toBeHidden({ timeout: 10_000 });
+
+    const intakeStatuses: number[] = [];
+    page.on("response", response => {
+      if (response.url().includes("/api/trpc/inventory.intake")) {
+        intakeStatuses.push(response.status());
+      }
+    });
+
+    await page.getByRole("button", { name: "Submit All Pending" }).click();
+
+    await expect
+      .poll(
+        async () =>
+          (await readAgGridCellText(page, rowIndex, "status")).toLowerCase(),
+        { timeout: 60_000 }
+      )
+      .toContain("submitted");
+
+    await expect
+      .poll(async () => intakeStatuses.length, { timeout: 30_000 })
+      .toBeGreaterThan(0);
+    expect(intakeStatuses.some(status => status >= 500)).toBeFalsy();
+
+    await expect(page.getByText(/Request ID:\s*REQ-/i)).toHaveCount(0);
+    await expect(
+      page.getByText(/An unexpected error occurred\. Please try again\./i)
+    ).toHaveCount(0);
+  });
+
+  test("should auto-populate Brand/Farmer when vendor is entered in-grid", async ({
+    page,
+  }): Promise<void> => {
+    test.setTimeout(120_000);
+    itemName = createItemName();
+    const vendorName = await findFirstVendorName(page);
+
+    await navigateToDirectIntake(page);
+
+    const addRowButton = page.getByRole("button", { name: "Add Row" });
+    const hasIntakeSurface = await addRowButton.isVisible().catch(() => false);
+    if (!hasIntakeSurface) {
+      test.skip(
+        true,
+        "Direct intake UI is not available in this deployment/role context"
+      );
+      return;
+    }
+
+    const rowIndex = 0;
+    await fillAgGridTextCell(page, rowIndex, "vendorName", vendorName);
+    await fillAgGridTextCell(page, rowIndex, "item", itemName);
+    await fillAgGridTextCell(page, rowIndex, "qty", "25");
+    await fillAgGridTextCell(page, rowIndex, "cogs", "99");
+    await setSelectedRowLocation(page, "Main Warehouse");
+
+    await page.getByRole("button", { name: "Submit Selected" }).click();
+
+    await expect
+      .poll(
+        async () =>
+          (await readAgGridCellText(page, rowIndex, "status")).toLowerCase(),
+        { timeout: 60_000 }
+      )
+      .toContain("submitted");
+
+    await expect(page.getByText("Brand/Farmer is required")).toHaveCount(0);
+    await expect(page.getByText(/Request ID:\s*REQ-/i)).toHaveCount(0);
+  });
+
+  test("should backfill Brand/Farmer from typed vendor even when vendor is not pre-existing", async ({
+    page,
+  }): Promise<void> => {
+    test.setTimeout(120_000);
+    itemName = createItemName();
+    const customVendorName = `E2E Vendor ${Date.now()}`;
+
+    await navigateToDirectIntake(page);
+
+    const addRowButton = page.getByRole("button", { name: "Add Row" });
+    const hasIntakeSurface = await addRowButton.isVisible().catch(() => false);
+    if (!hasIntakeSurface) {
+      test.skip(
+        true,
+        "Direct intake UI is not available in this deployment/role context"
+      );
+      return;
+    }
+
+    const rowIndex = 0;
+    await fillAgGridTextCell(page, rowIndex, "vendorName", customVendorName);
+    await fillAgGridTextCell(page, rowIndex, "item", itemName);
+    await fillAgGridTextCell(page, rowIndex, "qty", "12");
+    await fillAgGridTextCell(page, rowIndex, "cogs", "45");
+    await setSelectedRowLocation(page, "Main Warehouse");
+
+    const intakeStatuses: number[] = [];
+    page.on("response", response => {
+      if (response.url().includes("/api/trpc/inventory.intake")) {
+        intakeStatuses.push(response.status());
+      }
+    });
 
-    await page.getByRole("button", { name: "Submit All" }).click();
+    await page.getByRole("button", { name: "Submit Selected" }).click();
 
-    await waitForToast(page, "Successfully submitted");
+    await expect
+      .poll(async () => intakeStatuses.length, { timeout: 30_000 })
+      .toBeGreaterThan(0);
 
-    const statusCellText = await readAgGridCellText(page, rowIndex, "status");
-    expect(statusCellText).toContain("Submitted");
+    await expect(page.getByText("Brand/Farmer is required")).toHaveCount(0);
   });
 });
