# BUG-034: Complete Pagination Standard Implementation Across All Endpoints

## PROMPT FOR GEMINI EXECUTION

**Priority:** CRITICAL (P0)
**Estimated Time:** 16 hours
**Risk Level:** HIGH â€” Production code affecting all data-displaying features
**Last Updated:** 2025-12-22 (Red Hat QA findings incorporated)

---

## ğŸš¨ CRITICAL PRE-EXECUTION FINDINGS (READ FIRST)

**A comprehensive Red Hat QA Level 3 analysis was performed on 2025-12-22. The following critical findings MUST be understood before execution:**

### Finding 1: Four Different Pagination Contracts Exist

The codebase has evolved to have **FOUR incompatible pagination response structures**:

| Contract | Structure | Used By |
|----------|-----------|---------|
| **A** (Official) | `{ items, pagination: { total, limit, offset, hasMore, totalPages, currentPage } }` | `accounts.list` |
| **B** (Cursor) | `{ items, nextCursor, hasMore }` | `inventory.list`, `strains.*` |
| **C** (Hotfix) | `{ items, nextCursor: null, hasMore, pagination: { total: -1, limit, offset } }` | 21 hotfixed endpoints |
| **D** (Domain) | `{ invoices, total }` or `{ bills, total }` | `arApDb.*` |

**The frontend handles all four with defensive patterns like:**
```typescript
const data = Array.isArray(response) ? response : (response?.items ?? []);
```

### Finding 2: Actual Hotfix Count is 19, NOT 30

| Router | Claimed | Actual | Reason |
|--------|---------|--------|--------|
| strains.ts | 3 | **0** | Already uses Contract B |
| inventory.ts | 6 | **0** | Already uses Contract B |
| todoTasks.ts | 4 | **2** | getListTasks/getMyTasks fixed in pre-work |
| **Other routers** | 17 | **17** | Have BUG-033 hotfixes |
| **TOTAL** | 30 | **19** | 11 were fixed differently or in pre-work |

### Finding 3: Some DB Functions Already Return Structured Data

| DB Function | Returns | Router Action Needed |
|-------------|---------|---------------------|
| `todoTasksDb.getListTasks` | `{ items, total, limit, offset, hasMore }` | Extract and normalize |
| `todoTasksDb.getUserAssignedTasks` | `{ items, total, limit, offset, hasMore }` | Extract and normalize |
| `arApDb.getInvoices` | `{ invoices, total }` | Extract invoices array |
| `arApDb.getBills` | `{ bills, total }` | Extract bills array |
| `arApDb.getPayments` | `{ payments, total }` | Extract payments array |
| Others | Raw arrays | Add count query |

### Finding 4: todoTasks Bug Was Fixed (2025-12-22)

The `getListTasks` and `getMyTasks` procedures were double-wrapping structured data. This has been fixed - they now correctly extract `result.items` from the DB response.

---

## ğŸš¨ CRITICAL SAFETY DIRECTIVES

**READ THIS ENTIRE PROMPT BEFORE TAKING ANY ACTION.**

You are being tasked with a high-risk refactoring operation on a production ERP system. The previous attempt to implement pagination (PERF-003) caused a system-wide data visibility failure that required emergency hotfixes (BUG-031, BUG-032, BUG-033). 

**Your mission is to replace those hotfixes with a proper, permanent solution WITHOUT breaking anything.**

### NON-NEGOTIABLE RULES

1. **NEVER modify more than ONE file at a time without running tests.**
2. **NEVER remove a hotfix wrapper until the replacement is verified working.**
3. **NEVER assume a change is safe â€” verify with tests.**
4. **NEVER skip a QA gate â€” they exist to prevent cascading failures.**
5. **STOP IMMEDIATELY and report if any test fails unexpectedly.**

---

## ğŸ“‹ TASK OVERVIEW

### Current State (BUG-033 Hotfix)

The BUG-033 hotfix applied a wrapper layer to 25+ router procedures to convert raw array responses into the paginated structure the frontend expects:

```typescript
// HOTFIX (BUG-033): Wrap in paginated response structure
return {
  items: result,
  nextCursor: null,
  hasMore: Array.isArray(result) && result.length === limit,
};
```

**Problems with this approach:**
1. `nextCursor: null` â€” No true cursor-based pagination
2. `hasMore` is a heuristic â€” Incorrect at pagination boundaries
3. `total` is unknown â€” Frontend pagination UI may break
4. Wrappers are in the router layer â€” Should be in the DB layer
5. Inconsistent handling of different response shapes

### Target State (BUG-034 Solution)

All list-returning DB functions will return a standardized `PaginatedResult<T>`:

```typescript
// server/_core/pagination.ts
export interface PaginatedResult<T> {
  items: T[];
  nextCursor: string | null;
  hasMore: boolean;
  total: number;
}
```

Router procedures will pass through this structure unchanged, with no wrapper logic.

---

## ğŸ”’ QA GATE PROTOCOL

At each QA gate, you MUST:

1. **Run the full test suite:** `pnpm test --run`
2. **Run TypeScript check:** `pnpm tsc --noEmit`
3. **Verify no regressions:** Compare test results to baseline
4. **Document findings:** List any warnings, errors, or concerns
5. **STOP if any test fails:** Do not proceed until resolved

**QA Gate Format:**

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”’ QA GATE [NUMBER]: [GATE NAME]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š Test Results:
- Total Tests: [X]
- Passed: [X]
- Failed: [X]
- Skipped: [X]

ğŸ“ TypeScript Check:
- Errors: [X]
- Warnings: [X]

âœ… GATE STATUS: [PASS/FAIL]

ğŸ” Findings:
- [List any concerns, warnings, or observations]

ğŸ“‹ Files Modified Since Last Gate:
- [List files]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

**If a gate FAILS:**
1. STOP all work immediately
2. Document the failure in detail
3. Revert the changes that caused the failure
4. Report to the user before proceeding

---

## ğŸ“ AFFECTED FILES INVENTORY

### âš ï¸ CORRECTED INVENTORY (Post Red Hat QA)

**IMPORTANT:** The original inventory was inaccurate. The following has been verified against the actual codebase.

### Router Files WITH BUG-033 Hotfixes (19 procedures):

| File | Procedures | Hotfix Count | Notes |
|------|------------|--------------|-------|
| `server/routers/accounting.ts` | ledger.list, invoices.list, bills.list, payments.list, bankAccounts.list, bankTransactions.list, expenseCategories.list, expenses.list | 8 | DB returns domain-keyed objects |
| `server/routers/clients.ts` | list | 1 | DB returns raw array |
| `server/routers/inbox.ts` | getUnread, getByStatus | 2 | DB returns raw arrays |
| `server/routers/orders.ts` | getAll | 1 | DB returns raw array |
| `server/routers/purchaseOrders.ts` | getAll | 1 | DB returns raw array |
| `server/routers/samples.ts` | getPending | 1 | DB returns raw array |
| `server/routers/todoLists.ts` | getMyLists, getMembers | 2 | DB returns raw arrays |
| `server/routers/todoTasks.ts` | getOverdue, getDueSoon | 2 | DB returns raw arrays |
| `server/routers/vendors.ts` | getAll | 1 | DB returns raw array |

**Actual Total: 9 router files, 19 procedures with BUG-033 hotfixes**

### Router Files ALREADY Using Contract B (NO hotfixes needed):

| File | Procedures | Contract | Notes |
|------|------------|----------|-------|
| `server/routers/strains.ts` | list, search, fuzzySearch | Contract B | Uses `createCursorPaginatedResponse` |
| `server/routers/inventory.ts` | list, vendors, brands, views.list, profitability.top | Contract B | Uses cursor-based pagination |

**These 9 procedures were ALREADY fixed and do NOT need BUG-034 changes.**

### Router Files ALREADY Fixed (Phase 1 Pre-work):

| File | Procedures | Status | Notes |
|------|------------|--------|-------|
| `server/routers/todoTasks.ts` | getListTasks, getMyTasks | âœ… FIXED | Now extracts from structured DB response |

**These 2 procedures were fixed during BUG-034 pre-work (2025-12-22).**

### Per-Endpoint DB Return Type Analysis

**CRITICAL:** Before refactoring, understand what each DB function returns:

| DB Function | Current Return Type | Action Required |
|-------------|---------------------|-----------------|
| `todoTasksDb.getListTasks` | `{ items, total, limit, offset, hasMore }` | âœ… Already structured - extract items |
| `todoTasksDb.getUserAssignedTasks` | `{ items, total, limit, offset, hasMore }` | âœ… Already structured - extract items |
| `todoTasksDb.getOverdueTasks` | `TodoTask[]` | Add count query, wrap |
| `todoTasksDb.getTasksDueSoon` | `TodoTask[]` | Add count query, wrap |
| `arApDb.getInvoices` | `{ invoices, total }` | Extract invoices array, normalize |
| `arApDb.getBills` | `{ bills, total }` | Extract bills array, normalize |
| `arApDb.getPayments` | `{ payments, total }` | Extract payments array, normalize |
| `clientsDb.getClients` | `Client[]` | Add count query, wrap |
| `ordersDb.getAllOrders` | `Order[]` | Add count query, wrap |
| `inventoryDb.getBatchesByVendor` | `Batch[]` | Add count query, wrap |
| `inventoryDb.getDashboardStats` | `Stats object` | Special handling needed |
| `inboxDb.getUnreadInboxItems` | `InboxItem[]` | Add count query, wrap |
| `inboxDb.getInboxItemsByStatus` | `InboxItem[]` | Add count query, wrap |
| `samplesDb.getPendingSampleRequests` | `Sample[]` | Add count query, wrap |
| `todoListsDb.getUserLists` | `TodoList[]` | Add count query, wrap |
| `todoListsDb.getListMembers` | `Member[]` | Add count query, wrap |
| `purchaseOrdersDb.getAllPurchaseOrders` | `PurchaseOrder[]` | Add count query, wrap |
| `vendorsDb.getAllVendors` | `Vendor[]` | Add count query, wrap |

### DB Files (to be refactored):

| File | Functions to Refactor |
|------|----------------------|
| `server/inventoryDb.ts` | getBatchesWithDetails, getBatchesByVendor, getAllSuppliers, getAllBrands, getDashboardStats |
| `server/ordersDb.ts` | getAllOrders |
| `server/clientsDb.ts` | getClients |
| `server/accountingDb.ts` | getLedgerEntries |
| `server/arApDb.ts` | getInvoices, getBills, getPayments |
| `server/cashExpensesDb.ts` | getBankAccounts, getBankTransactions, getExpenses, getExpenseCategories |
| `server/todoListsDb.ts` | getUserLists, getListMembers |
| `server/todoTasksDb.ts` | getListTasks, getUserAssignedTasks, getOverdueTasks, getTasksDueSoon |
| `server/inboxDb.ts` | getUnreadInboxItems, getInboxItemsByStatus |
| `server/samplesDb.ts` | getPendingSampleRequests |
| `server/strainsDb.ts` | getAllStrains, searchStrains, fuzzySearchStrains |
| `server/purchaseOrdersDb.ts` | getAllPurchaseOrders |

---

## ğŸ”„ EXECUTION PHASES

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 0: PRE-WORK VERIFICATION (MANDATORY - 15 minutes)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Verify the codebase state matches this prompt before starting.

**Pre-Work Checklist:**

- [ ] **Verify hotfix count:** Run `grep -r "HOTFIX (BUG-033)" server/routers --include="*.ts" | wc -l` â€” Should be ~19
- [ ] **Verify strains.ts uses Contract B:** Check for `createCursorPaginatedResponse` usage
- [ ] **Verify inventory.ts list uses Contract B:** Check for cursor-based pagination
- [ ] **Verify todoTasks.ts getListTasks is fixed:** Should extract `result.items` from DB response
- [ ] **Verify todoTasks.ts getMyTasks is fixed:** Should extract `result.items` from DB response
- [ ] **Run TypeScript check:** `pnpm tsc --noEmit` â€” Should pass
- [ ] **Run tests:** `pnpm test --run` â€” Record baseline

**If any verification fails, STOP and investigate before proceeding.**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 0B: BASELINE ESTABLISHMENT (30 minutes)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Establish a known-good baseline before any changes.

**Steps:**

1. **Pull latest code:**
   ```bash
   cd TERP && git pull origin main
   ```

2. **Create a feature branch:**
   ```bash
   git checkout -b BUG-034-pagination-standard
   ```

3. **Run baseline tests:**
   ```bash
   pnpm test --run > baseline_test_results.txt 2>&1
   pnpm tsc --noEmit > baseline_tsc_results.txt 2>&1
   ```

4. **Record baseline metrics:**
   - Total tests passing
   - Total TypeScript errors (should be 0)
   - List any existing warnings

5. **Verify the application runs:**
   ```bash
   pnpm dev
   ```
   - Manually verify inventory page loads data
   - Manually verify orders page loads data
   - Manually verify dashboard widgets show data

**ğŸ”’ QA GATE 0: BASELINE VERIFICATION**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 1: CREATE PAGINATION INFRASTRUCTURE (2 hours)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Create the standardized pagination types and utilities.

**Steps:**

1. **Read the existing pagination file:**
   ```bash
   cat server/_core/pagination.ts
   ```

2. **Extend with standardized types (DO NOT replace existing code):**

   Add the following to `server/_core/pagination.ts`:

   ```typescript
   /**
    * Standardized paginated result structure for all list-returning endpoints.
    * This is the ONLY structure that should be returned from DB functions.
    */
   export interface PaginatedResult<T> {
     /** The items for the current page */
     items: T[];
     /** Cursor for the next page, or null if no more pages */
     nextCursor: string | null;
     /** Whether there are more items after this page */
     hasMore: boolean;
     /** Total count of all items (not just this page) */
     total: number;
   }

   /**
    * Input parameters for cursor-based pagination.
    */
   export interface PaginationInput {
     /** Maximum number of items to return */
     limit?: number;
     /** Cursor from previous page's nextCursor */
     cursor?: string | null;
   }

   /**
    * Default pagination values.
    */
   export const DEFAULT_PAGE_SIZE = 50;
   export const MAX_PAGE_SIZE = 100;

   /**
    * Helper to create a PaginatedResult from a query result.
    * 
    * @param items - The items returned from the query (should be limit + 1)
    * @param limit - The requested page size
    * @param total - The total count of all items
    * @param cursorField - The field to use for the cursor (default: 'id')
    */
   export function createPaginatedResult<T extends { id?: number | string }>(
     items: T[],
     limit: number,
     total: number,
     cursorField: keyof T = 'id'
   ): PaginatedResult<T> {
     // If we got more items than the limit, there are more pages
     const hasMore = items.length > limit;
     
     // Trim to the actual limit
     const trimmedItems = hasMore ? items.slice(0, limit) : items;
     
     // Get the cursor for the next page
     const lastItem = trimmedItems[trimmedItems.length - 1];
     const nextCursor = hasMore && lastItem ? String(lastItem[cursorField]) : null;
     
     return {
       items: trimmedItems,
       nextCursor,
       hasMore,
       total,
     };
   }

   /**
    * Helper to create an empty PaginatedResult.
    */
   export function emptyPaginatedResult<T>(): PaginatedResult<T> {
     return {
       items: [],
       nextCursor: null,
       hasMore: false,
       total: 0,
     };
   }
   ```

3. **Run tests after this change:**
   ```bash
   pnpm test --run
   pnpm tsc --noEmit
   ```

4. **Commit this change:**
   ```bash
   git add server/_core/pagination.ts
   git commit -m "feat(pagination): Add standardized PaginatedResult type and helpers for BUG-034"
   ```

**ğŸ”’ QA GATE 1: PAGINATION INFRASTRUCTURE**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 2: REFACTOR DB LAYER â€” ONE FILE AT A TIME (8 hours)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Refactor each DB file to return `PaginatedResult<T>` directly.

**âš ï¸ CRITICAL: Process ONE file at a time. Run tests after EACH file.**

**Pattern for each DB function:**

**BEFORE (raw array):**
```typescript
export async function getAllOrders(input: { limit?: number; offset?: number }) {
  const limit = input.limit || 50;
  const offset = input.offset || 0;
  
  const orders = await db.select()
    .from(ordersTable)
    .limit(limit)
    .offset(offset);
  
  return orders; // Raw array
}
```

**AFTER (PaginatedResult):**
```typescript
import { PaginatedResult, createPaginatedResult, DEFAULT_PAGE_SIZE } from './_core/pagination';

export async function getAllOrders(input: { 
  limit?: number; 
  cursor?: string | null;
}): Promise<PaginatedResult<Order>> {
  const limit = Math.min(input.limit || DEFAULT_PAGE_SIZE, MAX_PAGE_SIZE);
  
  // Build query with cursor-based pagination
  let query = db.select().from(ordersTable);
  
  if (input.cursor) {
    query = query.where(gt(ordersTable.id, parseInt(input.cursor)));
  }
  
  // Fetch limit + 1 to determine if there are more pages
  const orders = await query
    .orderBy(asc(ordersTable.id))
    .limit(limit + 1);
  
  // Get total count (separate query)
  const [{ count }] = await db.select({ count: sql<number>`count(*)` })
    .from(ordersTable);
  
  return createPaginatedResult(orders, limit, count);
}
```

**Order of DB file refactoring (from lowest to highest risk):**

1. `server/strainsDb.ts` â€” Low complexity, isolated module
2. `server/samplesDb.ts` â€” Low complexity, isolated module
3. `server/inboxDb.ts` â€” Low complexity, isolated module
4. `server/todoListsDb.ts` â€” Low complexity, isolated module
5. `server/todoTasksDb.ts` â€” Medium complexity
6. `server/clientsDb.ts` â€” Medium complexity
7. `server/vendorsDb.ts` (if exists, or functions in inventoryDb) â€” Medium complexity
8. `server/purchaseOrdersDb.ts` â€” Medium complexity
9. `server/ordersDb.ts` â€” High complexity, critical path
10. `server/accountingDb.ts` â€” High complexity
11. `server/arApDb.ts` â€” High complexity
12. `server/cashExpensesDb.ts` â€” High complexity
13. `server/inventoryDb.ts` â€” Highest complexity, most critical

**For EACH file:**

1. **Read the current implementation:**
   ```bash
   cat server/[filename].ts
   ```

2. **Identify all list-returning functions** (functions that return arrays)

3. **For each function:**
   - Add `PaginatedResult<T>` return type
   - Replace `offset` parameter with `cursor` parameter
   - Add cursor-based WHERE clause
   - Fetch `limit + 1` items
   - Add total count query
   - Use `createPaginatedResult` helper
   - Handle edge cases (empty results, null cursor)

4. **Run tests after each file:**
   ```bash
   pnpm test --run
   pnpm tsc --noEmit
   ```

5. **Commit after each file:**
   ```bash
   git add server/[filename].ts
   git commit -m "refactor([module]): Implement PaginatedResult in [filename] for BUG-034"
   ```

**ğŸ”’ QA GATE 2A: After strainsDb, samplesDb, inboxDb**
**ğŸ”’ QA GATE 2B: After todoListsDb, todoTasksDb, clientsDb**
**ğŸ”’ QA GATE 2C: After vendorsDb, purchaseOrdersDb, ordersDb**
**ğŸ”’ QA GATE 2D: After accountingDb, arApDb, cashExpensesDb**
**ğŸ”’ QA GATE 2E: After inventoryDb (CRITICAL)**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 3: UPDATE ROUTER LAYER â€” ONE FILE AT A TIME (4 hours)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Remove BUG-033 hotfix wrappers and pass through DB responses.

**âš ï¸ CRITICAL: Process ONE file at a time. Run tests after EACH file.**

**Pattern for each router procedure:**

**BEFORE (with BUG-033 hotfix):**
```typescript
getAll: publicProcedure
  .input(z.object({ limit: z.number().optional(), offset: z.number().optional() }))
  .query(async ({ input }) => {
    const orders = await ordersDb.getAllOrders(input);
    
    // HOTFIX (BUG-033): Wrap in paginated response structure
    const limit = input?.limit || 50;
    const offset = input?.offset || 0;
    return {
      items: orders,
      nextCursor: null,
      hasMore: Array.isArray(orders) && orders.length === limit,
      pagination: { total: -1, limit, offset }
    };
  }),
```

**AFTER (pass-through):**
```typescript
getAll: publicProcedure
  .input(z.object({ 
    limit: z.number().min(1).max(100).optional(),
    cursor: z.string().nullish(),
  }))
  .query(async ({ input }) => {
    // DB function now returns PaginatedResult directly
    return await ordersDb.getAllOrders({
      limit: input.limit,
      cursor: input.cursor,
    });
  }),
```

**Order of router file updates (match DB file order):**

1. `server/routers/strains.ts`
2. `server/routers/samples.ts`
3. `server/routers/inbox.ts`
4. `server/routers/todoLists.ts`
5. `server/routers/todoTasks.ts`
6. `server/routers/clients.ts`
7. `server/routers/vendors.ts`
8. `server/routers/purchaseOrders.ts`
9. `server/routers/orders.ts`
10. `server/routers/accounting.ts`
11. `server/routers/inventory.ts`

**For EACH file:**

1. **Read the current implementation:**
   ```bash
   cat server/routers/[filename].ts
   ```

2. **Identify all procedures with BUG-033 hotfix comments**

3. **For each procedure:**
   - Update input schema to use `cursor` instead of `offset`
   - Remove the hotfix wrapper code
   - Pass through the DB function response directly
   - Ensure input validation is present

4. **Run tests after each file:**
   ```bash
   pnpm test --run
   pnpm tsc --noEmit
   ```

5. **Commit after each file:**
   ```bash
   git add server/routers/[filename].ts
   git commit -m "refactor([module]): Remove BUG-033 hotfix from [filename], use PaginatedResult"
   ```

**ğŸ”’ QA GATE 3A: After strains, samples, inbox routers**
**ğŸ”’ QA GATE 3B: After todoLists, todoTasks, clients routers**
**ğŸ”’ QA GATE 3C: After vendors, purchaseOrders, orders routers**
**ğŸ”’ QA GATE 3D: After accounting router**
**ğŸ”’ QA GATE 3E: After inventory router (CRITICAL)**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 4: FRONTEND VERIFICATION (2 hours)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Verify all frontend components correctly consume the new structure.

**Steps:**

1. **Search for frontend pagination consumption:**
   ```bash
   grep -r "\.items" client/src --include="*.tsx" --include="*.ts" | head -50
   grep -r "nextCursor" client/src --include="*.tsx" --include="*.ts" | head -50
   grep -r "hasMore" client/src --include="*.tsx" --include="*.ts" | head -50
   ```

2. **Verify each major page loads correctly:**
   - [ ] Dashboard â€” All widgets display data
   - [ ] Inventory â€” List loads, pagination works
   - [ ] Orders â€” List loads, pagination works
   - [ ] Clients â€” List loads, pagination works
   - [ ] Accounting â€” All sub-pages load
   - [ ] Purchase Orders â€” List loads
   - [ ] Todo Lists â€” Lists and tasks load

3. **Test pagination functionality:**
   - [ ] First page loads correctly
   - [ ] "Load More" or pagination controls work
   - [ ] Empty states display correctly
   - [ ] Error states are handled

4. **Document any frontend issues found:**
   - If frontend expects `offset` instead of `cursor`, note the file and line
   - If frontend expects a different response shape, note the discrepancy

**ğŸ”’ QA GATE 4: FRONTEND VERIFICATION**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 5: FINAL TESTING & CLEANUP (2 hours)
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Comprehensive final verification and cleanup.

**Steps:**

1. **Run full test suite:**
   ```bash
   pnpm test --run
   ```

2. **Run TypeScript check:**
   ```bash
   pnpm tsc --noEmit
   ```

3. **Run linter:**
   ```bash
   pnpm lint
   ```

4. **Search for any remaining BUG-033 hotfix comments:**
   ```bash
   grep -r "BUG-033" server/routers --include="*.ts"
   grep -r "HOTFIX" server/routers --include="*.ts"
   ```
   - If any remain, they were missed â€” go back and fix them

5. **Verify no raw array returns remain:**
   ```bash
   grep -r "return await.*Db\." server/routers --include="*.ts" -A 5 | grep -v "PaginatedResult"
   ```

6. **Compare test results to baseline:**
   - Same number of tests passing
   - No new failures
   - No new TypeScript errors

7. **Manual smoke test:**
   - Start the application: `pnpm dev`
   - Navigate through all major pages
   - Verify data displays correctly

**ğŸ”’ QA GATE 5: FINAL VERIFICATION (CRITICAL)**

---

### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
### PHASE 6: MERGE & DEPLOY
### â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**Objective:** Merge the feature branch and deploy.

**Steps:**

1. **Squash commits (optional, for cleaner history):**
   ```bash
   git rebase -i main
   ```

2. **Push feature branch:**
   ```bash
   git push origin BUG-034-pagination-standard
   ```

3. **Create pull request** (if using PR workflow)

4. **Merge to main:**
   ```bash
   git checkout main
   git merge BUG-034-pagination-standard
   git push origin main
   ```

5. **Verify deployment:**
   - Monitor deployment logs
   - Verify application is healthy
   - Spot-check major pages

6. **Update roadmap:**
   - Mark BUG-034 as COMPLETE in `docs/roadmaps/MASTER_ROADMAP.md`
   - Add completion date

**ğŸ”’ QA GATE 6: POST-DEPLOYMENT VERIFICATION**

---

## ğŸš¨ EMERGENCY ROLLBACK PROCEDURE

If critical issues are discovered after deployment:

1. **Revert the merge commit:**
   ```bash
   git revert -m 1 [merge_commit_hash]
   git push origin main
   ```

2. **Document the issue** in a new bug report

3. **Notify the user immediately**

---

## ğŸ“‹ COMPLETION CHECKLIST

Before marking BUG-034 as complete, verify ALL of the following:

- [ ] All 13 DB files refactored to return `PaginatedResult<T>`
- [ ] All 11 router files updated to pass through DB responses
- [ ] All BUG-033 hotfix wrappers removed
- [ ] All tests passing (same count as baseline)
- [ ] Zero TypeScript errors
- [ ] Zero linter errors
- [ ] All major pages load data correctly
- [ ] Pagination controls work on all list pages
- [ ] Dashboard widgets display data
- [ ] No `nextCursor: null` hardcoded in routers
- [ ] No `hasMore: result.length === limit` heuristics in routers
- [ ] `total` count is accurate on all endpoints
- [ ] Feature branch merged to main
- [ ] Deployment verified healthy
- [ ] Roadmap updated

---

## ğŸ“ SESSION NOTES

Use this section to document your progress, findings, and any issues encountered:

```
Session Start: [DATE/TIME]
Session ID: [GENERATE]

Phase 0 Complete: [ ]
Phase 1 Complete: [ ]
Phase 2 Complete: [ ]
Phase 3 Complete: [ ]
Phase 4 Complete: [ ]
Phase 5 Complete: [ ]
Phase 6 Complete: [ ]

Issues Encountered:
- [List any issues]

Deviations from Plan:
- [List any deviations and justifications]

Total Time Spent: [X hours]
```

---

**END OF PROMPT**
