# DI-002: Fix Credit Application Race Condition

<!-- METADATA (for validation) -->
<!-- TASK_ID: DI-002 -->
<!-- TASK_TITLE: Fix Credit Application Race Condition -->
<!-- PROMPT_VERSION: 1.0 -->
<!-- LAST_VALIDATED: 2026-01-14 -->

**Repository:** https://github.com/EvanTenenbaum/TERP
**Task ID:** DI-002
**Estimated Time:** 8h
**Module:** `server/creditsDb.ts`

## Context

**Background:**
The credit application code at `server/creditsDb.ts:206-313` has a documented race condition. The code itself contains a comment: "RACE CONDITION RISK".

This can cause:
- Credits being double-applied
- Balance inconsistencies
- Financial data corruption

**Goal:**
Implement proper locking and transaction handling for credit operations.

**Success Criteria:**
- No race conditions in credit application
- Credits cannot be double-applied
- Atomic balance updates

## Implementation Guide

### Step 1: Identify the Race Condition

The issue likely occurs in the pattern:
```typescript
// BAD: Read-modify-write without locking
const balance = await getBalance(clientId);
const newBalance = balance + creditAmount;
await updateBalance(clientId, newBalance);
// Another request could update balance between read and write!
```

### Step 2: Add Database-Level Locking

Use SELECT FOR UPDATE to lock the row:

```typescript
import { withTransaction } from "./dbTransaction";
import { sql } from "drizzle-orm";

export async function applyCredit(clientId: number, amount: number) {
  return withTransaction(async (tx) => {
    // Lock the client row
    const [client] = await tx.execute(sql`
      SELECT * FROM clients
      WHERE id = ${clientId}
      FOR UPDATE
    `);

    if (!client) throw new Error("Client not found");

    // Now safe to update
    await tx.update(clients)
      .set({ creditBalance: sql`credit_balance + ${amount}` })
      .where(eq(clients.id, clientId));

    // Log the credit application
    await tx.insert(creditHistory).values({
      clientId,
      amount,
      appliedAt: new Date()
    });
  });
}
```

### Step 3: Use Atomic SQL Updates

Instead of read-modify-write, use atomic increments:

```typescript
// GOOD: Atomic update
await db.update(clients)
  .set({ creditBalance: sql`credit_balance + ${amount}` })
  .where(eq(clients.id, clientId));
```

### Step 4: Add Idempotency Key

Prevent double-application with idempotency:

```typescript
export async function applyCredit(
  clientId: number,
  amount: number,
  idempotencyKey: string
) {
  return withTransaction(async (tx) => {
    // Check if already applied
    const existing = await tx.select()
      .from(creditHistory)
      .where(eq(creditHistory.idempotencyKey, idempotencyKey))
      .limit(1);

    if (existing.length > 0) {
      return existing[0]; // Already applied, return existing
    }

    // Apply credit...
  });
}
```

### Step 5: Test Concurrent Requests

Add tests that simulate concurrent credit applications.

## Deliverables

- [ ] Wrap credit operations in transactions
- [ ] Add row-level locking (SELECT FOR UPDATE)
- [ ] Use atomic SQL updates where possible
- [ ] Implement idempotency key support
- [ ] Add concurrent access tests
- [ ] Remove "RACE CONDITION RISK" comment after fix

## Quick Reference

**File to modify:** `server/creditsDb.ts:206-313`

**Test concurrent access:**
```bash
# Use a load testing tool or write a test that spawns concurrent requests
```
