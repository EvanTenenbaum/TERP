# ST-045: Complete User Flow Mapping and Documentation

<!-- METADATA (for validation) -->
<!-- TASK_ID: ST-045 -->
<!-- TASK_TITLE: Complete User Flow Mapping and Documentation -->
<!-- PROMPT_VERSION: 1.0 -->
<!-- LAST_VALIDATED: 2026-01-08 -->

**Repository:** https://github.com/EvanTenenbaum/TERP  
**Task ID:** ST-045  
**Estimated Time:** 2-4d  
**Module:** `docs/`, `server/`, `client/`

‚ö†Ô∏è **SECURITY WARNING**

- NEVER include real secrets in this prompt
- Use placeholders like: `YOUR_API_KEY_HERE`
- Secrets belong in `.env` file only

---

## üìã Table of Contents

1. [Context](#context)
2. [Phase 0: Repo & DB Ingest](#phase-0-repo--db-ingest)
3. [Phase 1: Flow Archetype Enumeration](#phase-1-flow-archetype-enumeration)
4. [Phase 2: Variants & Edge Case Expansion](#phase-2-variants--edge-case-expansion)
5. [Phase 3: Consistency & Dead Flow Analysis](#phase-3-consistency--dead-flow-analysis)
6. [Phase 4: User Flow Matrix](#phase-4-user-flow-matrix)
7. [Phase 5: Flow Guide](#phase-5-flow-guide)
8. [Phase 6: Final Output](#phase-6-final-output)
9. [Reference Assets](#reference-assets)
10. [Implementation Guide](#implementation-guide)

---

## üéØ Context

**Background:**
You are operating in full Agent Mode.

You have:
‚Ä¢ Full access to the most recent ERP web app codebase and all embedded documentation (business rules, specs, comments, markdown, etc.).
‚Ä¢ Direct access to the ERP database (read/write) with the ability to:
  - run SQL queries
  - inspect schema (tables, columns, constraints, indexes)
  - inspect enums/status fields and their real observed values
  - inspect RBAC tables (roles, permissions, role_permissions, user_roles, user_permission_overrides)
  - inspect audit/event/log tables if they exist
  - run safe read-only profiling queries (counts, distinct status values, FK integrity checks)
‚Ä¢ You do NOT have:
  - the live site UI
  - a browser
  - screenshots

**Goal:**
Create a COMPLETE, EXHAUSTIVE map of all user flows in the ERP, including variants and edge cases, using:
(1) the codebase as the primary source of truth for available screens/routes, actions, handlers, and business logic
(2) the database as a verification/expansion source of truth for:
    - actual lifecycle/status values present
    - schema constraints that create edge cases
    - RBAC role‚Üípermission mappings actually deployed
    - data integrity hazards (nulls, orphan rows, impossible states)

**Success Criteria:**

- Complete User Flow Matrix covering all entities and flows
- Structured Flow Guide organized by Domain ‚Üí Entity ‚Üí Role ‚Üí Task
- All RBAC mismatches documented
- All dead/legacy flows identified
- No guessing - all uncertainties explicitly marked

---

## Phase 0: Repo & DB Ingest (MANDATORY)

### A) Repo scan:
1. Enumerate:
  ‚Ä¢ Domains (Inventory, Sales, Purchasing, CRM, Accounting, Reporting, Admin, Settings, Integrations, VIP Portal, Workflow/Todos/Calendar, etc.)
  ‚Ä¢ Entities per domain (Product, Batch/Lot, Customer/Client, Vendor, Order, Invoice, Payment, Purchase Order, Shipment, Adjustment, Return, Note, Tag, User, Role, Permission, etc.)
  ‚Ä¢ Routes/pages: extract the full client route registry and the nav/menu definitions.
  ‚Ä¢ API surface: extract every API handler/procedure and its auth/permission requirements.
  ‚Ä¢ Workflow states: identify status fields/enums and any state-machine-like guards.

### B) DB scan:
2. Introspect schema and capture:
  ‚Ä¢ Full table list + primary keys + foreign keys
  ‚Ä¢ Enums or "status" fields (either DB enums or constrained text fields) and constraints
  ‚Ä¢ Unique constraints and NOT NULL constraints that drive validation edge cases
  ‚Ä¢ Cascade rules and orphan-risk areas

3. RBAC truth from DB:
  ‚Ä¢ Extract every role, permission, and role_permissions mapping from DB
  ‚Ä¢ Extract any user permission overrides
  ‚Ä¢ Compare DB RBAC to code RBAC seeds (if present) and report mismatches:
    - permissions referenced in code but not present in DB
    - permissions present in DB but not referenced in code
    - roles referenced in code but not present in DB
    - endpoints guarded by "permission strings" that don't exist anywhere

**Deliverable from Phase 0 (internal only):** Domain list, Entity list, Role list, Key workflows list.

---

## Phase 1: Flow Archetype Enumeration (CODE-FIRST)

For each Entity, enumerate flows by archetype as implemented in code:
‚Ä¢ CREATE
‚Ä¢ READ/VIEW/SEARCH
‚Ä¢ UPDATE
‚Ä¢ DELETE/ARCHIVE
‚Ä¢ LINK/ASSOCIATE
‚Ä¢ STATE TRANSITIONS
‚Ä¢ ACTIONS/OPERATIONS (export, print, reconcile, sync, approve, post, etc.)
‚Ä¢ REPORTING/ANALYTICS
‚Ä¢ ADMIN/SETTINGS

For each flow:
‚Ä¢ Identify involved routes/pages/components
‚Ä¢ Identify involved backend handlers/services
‚Ä¢ Identify DB tables touched (directly or via service layer)

---

## Phase 2: Variants & Edge Case Expansion (CODE + DB)

For each flow, enumerate variants along:

### 1) ROLE
‚Ä¢ Determine exact role/permission requirements from backend authorization.
‚Ä¢ Cross-check with DB role_permissions to list which deployed roles can actually execute.

### 2) STATE
‚Ä¢ For stateful entities, enumerate allowed actions per state using:
  ‚Ä¢ code guards/branching (service + router logic)
  ‚Ä¢ DB observed values (SELECT DISTINCT status FROM <table>)

### 3) CONDITIONS / BUSINESS RULES
‚Ä¢ Extract conditional branches from code:
  ‚Ä¢ inventory availability
  ‚Ä¢ pricing/discount rules
  ‚Ä¢ credit limit / AR aging
  ‚Ä¢ tax/currency logic (if present)
  ‚Ä¢ approval requirements
  ‚Ä¢ vendor/client active flags
  ‚Ä¢ integration failure/retry paths
‚Ä¢ Validate risk areas using DB constraints + real data patterns (nulls reminded by NOT NULL fails, uniqueness, FK violations, etc.)

### 4) UI ENTRY PATHS (INFERRED)
‚Ä¢ From code only:
  ‚Ä¢ nav/menu ‚Üí route
  ‚Ä¢ route ‚Üí page component
  ‚Ä¢ page buttons/links ‚Üí other routes/actions
‚Ä¢ If a backend flow has no route and no client reference, classify as "API-only".

### 5) HAPPY VS SAD PATHS
‚Ä¢ Enumerate success + error branches:
  ‚Ä¢ validation errors
  ‚Ä¢ permission errors
  ‚Ä¢ not found / stale state
  ‚Ä¢ conflict/constraint failures
  ‚Ä¢ integration errors (if any)
‚Ä¢ Where possible, tie sad paths to concrete DB constraints or enum/state conflicts.

---

## Phase 3: Consistency & Dead Flow Analysis (CODE + DB)

For every candidate flow, confirm:
‚Ä¢ Backend implementation exists
‚Ä¢ Client wiring exists (or does not) and classify:
  - Fully wired: route/component + client call + backend + DB writes/reads align
  - Partially wired: something missing (UI without handler, handler without UI, etc.)
  - Dead/legacy: unreachable/unreferenced/obsolete guards or routes
‚Ä¢ Compare "permissions required by endpoint" vs "permissions present in DB" and flag mismatches.

---

## Phase 4: User Flow Matrix (TICK LIST)

Output as Markdown tables (and also save as CSV if you can).

Each row must be granular enough to represent a distinct flow variant.

**Columns (minimum):**
‚Ä¢ Domain
‚Ä¢ Entity
‚Ä¢ Flow Name
‚Ä¢ Archetype
‚Ä¢ Role(s) (DB-derived, not just seed)
‚Ä¢ Permission(s) required
‚Ä¢ State(s) (and how determined: code enum vs DB distinct values)
‚Ä¢ Key Conditions / Variants
‚Ä¢ UI Entry Path(s) (route + component + link/button source, if inferable)
‚Ä¢ Preconditions
‚Ä¢ Postconditions (state changes, side effects)
‚Ä¢ Related Entities
‚Ä¢ Related Reports/Dashboards
‚Ä¢ DB Tables touched (and key fields)
‚Ä¢ Implementation Status (Fully wired / Partially wired / API-only / Dead)
‚Ä¢ Known Issues / Uncertainties
‚Ä¢ Documentation Status
‚Ä¢ QA Status (Code-Level)

---

## Phase 5: Flow Guide (TEXTUAL)

Organize:
Domain ‚Üí Entity ‚Üí Role ‚Üí Task (Flow)

For each flow row:
‚Ä¢ Business purpose
‚Ä¢ Preconditions
‚Ä¢ Happy path steps (conceptual UI steps derived from routes/components)
‚Ä¢ Backend path (handler/service functions)
‚Ä¢ DB impact (tables/fields, state transitions)
‚Ä¢ Key variants (role/state/conditions)
‚Ä¢ Validations & error states
‚Ä¢ Accounting/inventory/reporting impacts where applicable
‚Ä¢ Implementation status + contradictions/mismatches

---

## Phase 6: Final Output

Provide:
1) USER FLOW MATRIX (Markdown tables + CSV)
2) FLOW GUIDE (Markdown)

**Quality bar:**
‚Ä¢ No guessing. If unclear, mark uncertainty and point to the exact code/DB evidence that's missing.
‚Ä¢ Prefer concrete names: routes, components, procedures, service functions, tables, columns, permission strings.
‚Ä¢ Explicitly call out RBAC mismatches, dead flows, and contradictions.

---

## Reference Assets

The following reference files are provided in `docs/assets/ST-045/`:

| File | Description |
|------|-------------|
| `TERP_Routes.csv` | Extracted route definitions from the codebase |
| `TERP_Flow_Guide.md` | Previous flow guide documentation |
| `TERP_RBAC_Permission_Mismatches.csv` | Known RBAC permission mismatches |
| `TERP_User_Flow_Matrix_FULL.csv` | Previous user flow matrix (to be updated/expanded) |

Use these as starting points and expand/correct based on current codebase and database state.

---

## Implementation Guide

### Step 1: Environment Setup
1. Clone the repository and ensure database access
2. Review the reference assets in `docs/assets/ST-045/`
3. Set up database connection for schema introspection

### Step 2: Codebase Analysis
1. Extract all routes from `client/src/` router configuration
2. Extract all tRPC procedures from `server/routers/`
3. Map permissions from middleware and guards
4. Identify all status/enum fields in schema

### Step 3: Database Analysis
1. Run schema introspection queries
2. Extract RBAC tables (roles, permissions, role_permissions)
3. Compare DB state to code seeds
4. Document mismatches

### Step 4: Flow Documentation
1. Create flow matrix following Phase 4 format
2. Write flow guide following Phase 5 format
3. Mark all uncertainties explicitly

### Step 5: Deliverables
1. Update `docs/assets/ST-045/TERP_User_Flow_Matrix_FULL.csv`
2. Update `docs/assets/ST-045/TERP_Flow_Guide.md`
3. Create summary report of findings

---

## ‚ö° Quick Reference

**Key Directories:**
- Routes: `client/src/routes/` or `client/src/App.tsx`
- Routers: `server/routers/`
- Schema: `server/db/schema.ts` or `drizzle/`
- Services: `server/services/`

**Key Commands:**
```bash
# Find all routes
grep -r "path:" client/src/ --include="*.tsx"

# Find all tRPC procedures
grep -r "publicProcedure\|protectedProcedure" server/routers/

# Find permission checks
grep -r "hasPermission\|requirePermission" server/
```

---

## üÜò Troubleshooting

**Database Connection Issues:**
- Ensure DATABASE_URL is set in .env
- Check connection string format

**Missing Routes:**
- Check for lazy-loaded routes
- Review route guards that may hide routes

**RBAC Mismatches:**
- Compare `server/db/seed.ts` with actual DB state
- Check for migration scripts that modify permissions
