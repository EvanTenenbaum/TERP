# REL-005: Idempotency Keys for Critical Mutations (Replay-Safe Money + Inventory)

<!-- METADATA (for validation) -->
<!-- TASK_ID: REL-005 -->
<!-- TASK_TITLE: Idempotency Keys for Critical Mutations -->
<!-- PROMPT_VERSION: 1.0 -->
<!-- LAST_VALIDATED: 2026-01-08 -->

**Repository:** https://github.com/EvanTenenbaum/TERP  
**Task ID:** REL-005  
**Estimated Time:** 2d  
**Module:** `drizzle/`, `server/_core/`, `server/routers/`

## Implementation Guide

### Problem
Retries/timeouts can cause double application (payments, credits, adjustments, fulfillment) unless replay-safe.

### Solution
- Add table `idempotency_keys` (unique key + scope + requestHash + status + resultRef + timestamps).
- Implement helper/middleware that:
  - locks or checks key in transaction
  - if completed, returns prior result
  - otherwise executes and stores resultRef

### Apply To (Minimum)
- Record payment
- Apply credit
- Receive inventory
- Fulfill/ship
- Generate invoice
- Reverse/void money ops
- Reverse movements

### Files to Modify
- Schema/migrations: `drizzle/`
- Core: `server/_core/` (new `idempotency.ts` or similar)
- Routers/services that implement above actions

### Tests
- Re-run identical calls N times with same idempotency key -> single effect in DB.

### Acceptance Criteria
- Double-apply is impossible with the same idempotency key.
- Replay returns the exact same result reference deterministically.
